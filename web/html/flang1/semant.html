
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Semantic Analyzer &#8212; Flang 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Transformer" href="transform.html" />
    <link rel="prev" title="Parser" href="parser.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Flang 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Semantic Analyzer</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="parser.html">Parser</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="transform.html">Transformer</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="semantic-analyzer">
<h1>Semantic Analyzer<a class="headerlink" href="#semantic-analyzer" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The Semantic Analyzer compiler module performs three major functions:</p>
<ul class="simple">
<li><p>generates the first internal representation of the
executable statements of the user’s subprogram (AST’s).</p></li>
<li><p>enters symbols and their attributes into the symbol table
and related global data structures.</p></li>
<li><p>performs semantic error checking and issues appropriate
diagnostic messages.</p></li>
</ul>
</div>
<div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="global-data-structures">
<h3>Global Data Structures<a class="headerlink" href="#global-data-structures" title="Permalink to this headline">¶</a></h3>
<p><em>Symbol Table</em> — described in section 11.</p>
<p><em>AST’s</em> — internal representation of executable statements written to a temporary
file.  Refer to appendix IV
for a list of the AST opcodes and descriptions of their meanings.</p>
<p><em>astb.df</em> — external temporary file containing information generated from the
processing of initializations.  See section 14.</p>
<p><em>Data Initialization File</em> — external temporary file containing information generated by the Semantic
Analyzer and other phases to effect initializations of compiler-created
variables.
See section 14.</p>
<p><em>Reference File</em> — external temporary file containing information on symbol usage
for the Cross Reference Listing.  See section 13.</p>
</div>
<div class="section" id="semantic-stack">
<h3>Semantic Stack<a class="headerlink" href="#semantic-stack" title="Permalink to this headline">¶</a></h3>
<p>The Semantic Stack is operated in parallel with the Parse Stack;
the same variable is used to point to the top of each (see section 4).</p>
<p>Each stack entry consists of 5 words (of type <code class="docutils literal notranslate"><span class="pre">INT</span></code>).  The contents
of each stack entry depend on the corresponding grammar symbol.
For example, for the symbol \*(gf&lt;ident&gt;\*(rf, the stack contains a
symbol table pointer to the identifier; for the symbol \*(gf&lt;arg list&gt;\*(rf
the stack contains pointers to the beginning and end of the
list, etc.
Each stack entry consists of an AST field.</p>
<p>For terminal symbols of the grammar, the first word of the
corresponding semantic stack entry is set to the token value returned
by the Scanner (see section 3).  For instance, for \*(gf&lt;integer&gt;\*(rf it
is the 32-bit integer value of the constant.  The exceptions to this rule
are constants requiring more than 32-bits of storage such as a
complex constant.  In these cases the semantic stack entry contains a
symbol table pointer to the constant.</p>
<p>For a non-terminal symbol, the sections of semantic code associated with
productions which generate the symbol are responsible for
ensuring that the proper values are put into the stack entry.</p>
<p>Macros defined in <em>semant.h</em> are used to access the words of
the semantic stack.  These are of the form
<code class="docutils literal notranslate"><span class="pre">SST_\\*(gf&lt;name&gt;\\*(cfP</span></code> and
<code class="docutils literal notranslate"><span class="pre">SST_\\*(gf&lt;name&gt;\\*(cfG</span></code>.
For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SST_SYMG(s);
SST_SYMP(s, sptr);
</pre></div>
</div>
<p>The most important type of stack entry is the one used
for \*(gf&lt;expression&gt;\*(rf and a number of other associated grammar
symbols such as \*(gf&lt;primary&gt;\*(rf, \*(gf&lt;postfix exp&gt;\*(rf,
\*(gf&lt;add exp&gt;\*(rf, etc.
This entry itself has several formats, depending on the
value of the stack identifier.  The following macros are
used to reference the various fields described below:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>FIELD</p></td>
<td><p>MACRO</p></td>
</tr>
<tr class="row-even"><td colspan="2"><p>_</p></td>
</tr>
<tr class="row-odd"><td><p>stack type</p></td>
<td><p>SST_IDP, SST_IDG</p></td>
</tr>
<tr class="row-even"><td><p>AST pointer</p></td>
<td><p>SST_ASTP, SST_ASTG</p></td>
</tr>
<tr class="row-odd"><td><p>Constant value</p></td>
<td><p>SST_CVALP, SST_CVALG</p></td>
</tr>
<tr class="row-even"><td><p>Symbol pointer</p></td>
<td><p>SST_SYMP, SST_SYMG</p></td>
</tr>
</tbody>
</table>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">S_EXPR</span></code></dt><dd><p>AST’s have been written for the associated expression.</p>
<dl class="simple">
<dt>word2</dt><dd><p>data type of the expression (pointer into dtype area, see section 11.4.1).</p>
</dd>
<dt>word5</dt><dd><p>pointer to AST.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_LVALUE</span></code></dt><dd><p>The expression is one which can be used as an lvalue,
and AST’s have been written for it.</p>
<dl class="simple">
<dt>word2</dt><dd><p>dtype.</p>
</dd>
<dt>word3</dt><dd><p>symbol of lvalue.</p>
</dd>
<dt>word4</dt><dd><p>shape.</p>
</dd>
<dt>word5</dt><dd><p>pointer to AST.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_LOGEXPR</span></code></dt><dd><p>Logical expression.  An expression of the form
<code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">.and.</span> <span class="pre">e2</span></code> or <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">.or.</span> <span class="pre">e2</span></code>, or
the logical negation (<code class="docutils literal notranslate"><span class="pre">.not.</span></code> operator) of one of these.
See discussion of logical expression processing below.</p>
<dl class="simple">
<dt>word1</dt><dd><p>pointer to LAND or LOR AST.</p>
</dd>
<dt>word2</dt><dd><p>dtype = <code class="docutils literal notranslate"><span class="pre">DT_INT</span></code>.</p>
</dd>
<dt>word5</dt><dd><p>pointer to AST.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_CONST</span></code></dt><dd><p>the associated expression is a constant.</p>
<dl class="simple">
<dt>word1</dt><dd><p>32-bit constant value if data type of
constant is an integer type,
otherwise a symbol table pointer to an
entry for the constant.</p>
</dd>
<dt>word2</dt><dd><p>data type of the constant.
Note that although the Scanner only returns
constants of type <code class="docutils literal notranslate"><span class="pre">DT_INT</span></code> or <code class="docutils literal notranslate"><span class="pre">DT_FLOAT</span></code>, many other
data types are possible here because of the
constant folding of type cast operations.</p>
</dd>
<dt>word5</dt><dd><p>pointer to AST.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_STAR</span></code></dt><dd><p>created when
<code class="docutils literal notranslate"><span class="pre">\*</span></code>
is seen as a specifier for a dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_VAL</span></code></dt><dd><p>created when the
<code class="docutils literal notranslate"><span class="pre">%VAL</span></code>
built-in is seen;
word5 is the pointer to the AST of the operand.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_IDENT</span></code></dt><dd><p>identifier</p>
<dl class="simple">
<dt>word1</dt><dd><p>a symbol table pointer to an
entry for the identifier.</p>
</dd>
<dt>word2</dt><dd><p>data type of the identifier.</p>
</dd>
<dt>word5</dt><dd><p>pointer to A_ID AST.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_LABEL</span></code></dt><dd><p>label</p>
<dl class="simple">
<dt>word1</dt><dd><p>a symbol table pointer to an
entry for the label.</p>
</dd>
<dt>word5</dt><dd><p>pointer to the A_LABEL AST.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_STFUNC</span></code></dt><dd><p>statement function definition</p>
<dl class="simple">
<dt>word1</dt><dd><p>a symbol table pointer to an
entry for the statement function which is being defined.</p>
</dd>
<dt>word2</dt><dd><p>pointer to the list of the statement function’s formal arguments.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S_ACONST</span></code></dt><dd><p>array constant</p>
<dl class="simple">
<dt>word1</dt><dd><p>a symbol table pointer to an
entry for the array temporary representing the constant.</p>
</dd>
<dt>word2</dt><dd><p>its data type record.</p>
</dd>
<dt>word3</dt><dd><p>the pointer to the array constructor list representing the
values of the array.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="semantic-stack-lists">
<h3>Semantic Stack Lists<a class="headerlink" href="#semantic-stack-lists" title="Permalink to this headline">¶</a></h3>
<p>Often a list of entities must be tied to a semantic stack entry.  This happens
for identifier lists to program entry points, array subscript lists,
subprogram call argument lists, and character substring lists.  The semantic
analyzer uses <em>item lists</em> to retain semantic stack information until
enough information is gathered about the statement being parsed.  For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo(a, b, 1, 17, c)
</pre></div>
</div>
<p>could be an array reference or a function call.  Therefore, the semantic
analyzer cannot generate ASTs while processing each of the arguments.  The
only alternative is to save any required information about the arguments in an
item list until it is determined what kind of reference is being made.</p>
<p>The following structure defines an item list.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct xyyz {
 struct xyyz \*next;
 int          ast;
 union {
     int sptr;
     struct sst \*stkp;
     INT conval;
 } t;
} ITEM;
</pre></div>
</div>
<p>The first field of an item entry is used to point to the next item in the
list.  A value of <code class="docutils literal notranslate"><span class="pre">LIST_END</span></code> is used to mark the end of the list.
The second field is the AST pointer of the argument.
There are four types of item entries; symbol pointer,  semantic stack
pointer, and constant value.  They are each handled in a similar manner.  The
semantic stack item list entry is discussed here because it is more complex.</p>
<p>An argument list that could represent an array reference, character substring,
or function call is represented by an item list of semantic stack pointers.
An argument can be:</p>
<dl class="simple">
<dt>&lt;expression&gt;</dt><dd><p>a simple expression which denotes a function argument or a
single subscript,</p>
</dd>
<dt>&lt;ident&gt; = &lt;expression&gt;</dt><dd><p>an identifier keyword which is allowed in certain intrinsic or subprogram
calls,</p>
</dd>
<dt>&lt;expression&gt;:&lt;expression&gt;:&lt;expression&gt;</dt><dd><p>or a subscript triplet which denotes a vector slice.</p>
</dd>
</dl>
<p>An argument that is a simple expression is represented by a semantic stack
entry of the normal type <code class="docutils literal notranslate"><span class="pre">S_IDENT</span></code> or <code class="docutils literal notranslate"><span class="pre">S_EXPR</span></code>.</p>
<p>An argument that is a keyword entry is represented by the corresponding
semantic stack id of S_KEYWORD.  The <code class="docutils literal notranslate"><span class="pre">SST_E3</span></code> field of the semantic
stack entry points to another semantic stack entry containing the expression.</p>
<p>An argument that is a subscript triplet is represented by a semantic stack id
of <code class="docutils literal notranslate"><span class="pre">S_TRIPLE</span></code>.  The <code class="docutils literal notranslate"><span class="pre">SST_E1</span></code>, <code class="docutils literal notranslate"><span class="pre">SST_E2</span></code>, and
<code class="docutils literal notranslate"><span class="pre">SST_E3</span></code> fields of that semantic stack entry point to other semantic
stack entries which represent the initial element, the ending element, and the
stride for the triplet notation.</p>
</div>
<div class="section" id="structure-stack">
<h3>Structure Stack<a class="headerlink" href="#structure-stack" title="Permalink to this headline">¶</a></h3>
<p>The structure stack is used to keep track of the current nesting of
<code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code>, <code class="docutils literal notranslate"><span class="pre">UNION</span></code>, and <code class="docutils literal notranslate"><span class="pre">MAP</span></code>
statements.  The variables <code class="docutils literal notranslate"><span class="pre">sem.stsk_base</span></code> and
<code class="docutils literal notranslate"><span class="pre">sem.stsk_depth</span></code> are used to find the current stack top.  The
“Structure Processing” section describes how the structure stack is used by the
semantic analyzer.</p>
<p>The form of the structure stack is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
 char   type;
    int    sptr;
    int    dtype;
 int    last;
    CONST \*ict_beg;
    CONST \*ict_end;
} STSK;
</pre></div>
</div>
<p>.BS</p>
<dl class="simple">
<dt>t``type``</dt><dd><p>the type of statement for which a stack entry represents (‘s’, ‘u’, or ‘m’
for <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code>, <code class="docutils literal notranslate"><span class="pre">UNION</span></code>, or <code class="docutils literal notranslate"><span class="pre">MAP</span></code>, respectively).</p>
</dd>
<dt>t``sptr``</dt><dd><p>symbol table pointer to the first symbol in a linked list of symbols
representing the field name list of a <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code> statement.
For example, <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span> <span class="pre">/A/</span> <span class="pre">B,C,D(10)</span></code>, the <code class="docutils literal notranslate"><span class="pre">sptr</span></code> would point
to <code class="docutils literal notranslate"><span class="pre">B</span></code> which is linked to <code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">D</span></code>.
For <code class="docutils literal notranslate"><span class="pre">UNION</span></code> and <code class="docutils literal notranslate"><span class="pre">MAP</span></code>, this field is the symbol table
pointer to the compiler-created <code class="docutils literal notranslate"><span class="pre">ST_MEMBER</span></code> symbol of
type  <code class="docutils literal notranslate"><span class="pre">TY_UNION</span></code> or <code class="docutils literal notranslate"><span class="pre">TY_STRUCT</span></code>, respectively.</p>
</dd>
<dt>t``dtype``</dt><dd><p>data type pointer to an entry of type <code class="docutils literal notranslate"><span class="pre">TY_STRUCT</span></code> (<code class="docutils literal notranslate"><span class="pre">TY_UNION</span></code>)
for the current structure.</p>
</dd>
<dt>t``last``</dt><dd><p>symbol table pointer to the last member which belongs to the
structure with respect to the scope.
All members which are at the same scoping level are linked together
via the <code class="docutils literal notranslate"><span class="pre">VARIANT</span></code> field in reverse order.</p>
</dd>
<dt>t``ict_beg``</dt><dd><p>pointer to the beginning of the initializer constant tree for the
current structure.</p>
</dd>
<dt>t``ict_end``</dt><dd><p>pointer to the end of the initializer constant tree for the
current structure.
.BE</p>
</dd>
</dl>
</div>
<div class="section" id="initializer-constant-tree">
<h3>Initializer Constant Tree<a class="headerlink" href="#initializer-constant-tree" title="Permalink to this headline">¶</a></h3>
<p>An Initializer Constant Tree is built (in dynamic storage) as the initializer
for a static or external variable is processed (for automatic variables, AST’s
are generated as for an ordinary expression, then an assignment statement is
simulated).</p>
<p>The tree consists of nodes linked by (absolute) pointers, and its structure
parallels the tree defined by the nesting of braces ({}) in the C language form
of the initializer and by <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code>’s in the Fortran language form
of the initializer.</p>
<p>Normally, when processing a data initialization statement, the initializer
constant tree is allocated, built, passed to <em>dinit.c</em> to generate
dinit records, and finally deallocated.  This all occurs during the processing
of a single Fortran statement.  This works for <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statements and
type declaration statements but will not work for <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code> statements.
<code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code> statements should not cause dinit records to be written.
The dinit records should only be written for an instance of a structure declared
with a <code class="docutils literal notranslate"><span class="pre">RECORD</span></code> statement.  This implies that the initializer constant
tree cannot be deallocated during end of statement processing.  In fact,
structure initializer constant trees must be allocated from memory that is not
deallocated until end of program module processing.</p>
<p>The format of nodes is defined by the following C structure declaration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct const {
    struct const \*next;
    struct const \*subc;
    INT           conval;
    INT           repeat;
    int           sptr;
    int           dtype;
}
</pre></div>
</div>
<p>There are two types of nodes (distinguished by the value of subc):</p>
<p><em>Set Node (subc != 0)</em> — represents a set of constants in a structure group.
.BS</p>
<dl class="simple">
<dt>t``next``</dt><dd><p>pointer to next element of set (if any)
which is contained within the parent set.  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if this
set is at the top level, or is the last
element.</p>
</dd>
<dt>t``subc``</dt><dd><p>pointer to the first element in the initializer constant tree of the
subordinate structure.</p>
</dd>
<dt>t``conval``</dt><dd><p>not used.</p>
</dd>
<dt>t``repeat``</dt><dd><p>not used.</p>
</dd>
<dt>t``sptr``</dt><dd><p>Pointer to symbol table entry of variable, array, or structure member
to initialize.  If zero, the area we are currently initializing is continued
to be initialized.</p>
</dd>
<dt>t``dtype``</dt><dd><p>Data type record of the structure.
.BE</p>
</dd>
</dl>
<p><em>Terminal Nodes (subc = 0)</em> — represent the occurrence of a constant (or constant expression)
in the initializer.
.BS</p>
<dl class="simple">
<dt>t``next``</dt><dd><p>same as for Set Nodes.</p>
</dd>
<dt>t``subc``</dt><dd><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt>t``conval``</dt><dd><p>32 bit constant value for integer types, else symbol table
pointer to entry for constant.</p>
</dd>
<dt>t``repeat``</dt><dd><p>The number of times to repeat the constant <code class="docutils literal notranslate"><span class="pre">in</span></code> conval.</p>
</dd>
<dt>t``sptr``</dt><dd><p>same as for Set Nodes.</p>
</dd>
<dt>t``dtype``</dt><dd><p>data type of the constant.
.BE</p>
</dd>
</dl>
</div>
<div class="section" id="initializer-variable-list">
<h3>Initializer Variable List<a class="headerlink" href="#initializer-variable-list" title="Permalink to this headline">¶</a></h3>
<p>An Initializer Variable List goes hand in hand with the Initializer Constant
Tree.  It contains the list of variables to be initialized by the constants
in the Constant Initializer Tree.  It is built in dynamic storage as the
initializer for a static or external variable is processed.  The Initializer
Variable List is only used during <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statement processing.
Therefore, its memory space can be released during end of statement
processing.</p>
<p>The format of the Initializer Variable List is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   struct dinit_var {
       short id;    /\* {Dostart, Doend, Varref} \*/
       union {
           struct {
               short indvar;
               short lowbd, upbd, step;
           } dostart;
           struct {
               struct dinit_var \*dostart;
           } doend;
           struct {
            int id;
            int ptr;
            int dtype;
            int shape;
           } varref;
      } u;
      struct dinit_var \*next;
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">next</span></code> field links together more than one variable list element.
A variable list element can be one of three types:  a simple variable
reference, an implied-do start, or an implied-do end.</p>
<p><em>Simple Variable</em> — This is a variable, array, or array element reference.  Information from the
semantic stack is copied to this entry.
.BS</p>
<dl class="simple">
<dt>tid</dt><dd><p>This holds the value of the <code class="docutils literal notranslate"><span class="pre">SST_ID</span></code> field in the semantic stack.</p>
</dd>
<dt>tptr</dt><dd><p>This can either be a symbol table pointer or an AST pointer.  It will be an
AST pointer for an array element reference (i.e. it points to an SUBSCR
AST).</p>
</dd>
<dt>tdtype</dt><dd><p>This contains the data type of the variable from the semantic stack.</p>
</dd>
<dt>tshape;</dt><dd><p>This contains the shape of vector references from the semantic stack.
.BE
<em>Do-start</em> — This marks the beginning of an implied DO-loop.
.BS</p>
</dd>
<dt>tindvartlowbdtupbdtstep</dt><dd><p>This contains AST pointers to the index variable, the lower bound,
the upper bound, and the step increment for the DO-loop.</p>
</dd>
<dt>tstep</dt><dd><p>.BE
<em>Do-end</em> — This marks the end of an implied DO-loop.  It simply points back to the
associated Do-start entry.</p>
</dd>
</dl>
</div>
<div class="section" id="loop-stack">
<h3>Loop Stack<a class="headerlink" href="#loop-stack" title="Permalink to this headline">¶</a></h3>
<p>The Loop Stack is used to keep track of the
current nesting of do, while, and forall loops, and where and block
if statements.
It consists of fixed size records and is allocated a contiguous
area of dynamic storage.
The variable sem.loop_depth is used to find the current stack top.</p>
<p>Each record contains a field which is the beginning line number of the
control statement.
The remaining contents of a record depends on the type of loop it represents:</p>
<p><em>Do Loop</em> — .BS</p>
<dl>
<dt>tdo_label</dt><dd><p>symbol table pointer to the label of the last statement in the loop;
this field may be zero.</p>
</dd>
<dt>tdoinfo</dt><dd><p>pointer to the <code class="docutils literal notranslate"><span class="pre">DOINFO</span></code> record for the do/dowhile loop (see below).</p>
</dd>
<dt>tname</dt><dd><p>construct name.
This is just an index into the symbol names area; this field
is zero is the construct is unnamed.</p>
</dd>
<dt>texit_label</dt><dd><p>pointer to the symbol table entry for the label of any EXIT statement which
appeared in the DO body; 0 if an EXIT statement did not appear in the body.</p>
</dd>
<dt>tcycle_label</dt><dd><p>pointer to the symbol table entry for the label of any CYCLE statement which
appeared in the DO body; 0 if a CYCLE statement did not appear in the body.</p>
<p>.BE</p>
</dd>
</dl>
<p><em>Do While Loop</em> — .BS</p>
<dl>
<dt>tdo_label</dt><dd><p>symbol table pointer to the label of the last statement in the loop;
this field may be zero.</p>
</dd>
<dt>tdoinfo</dt><dd><p>pointer to the <code class="docutils literal notranslate"><span class="pre">DOINFO</span></code> record for the do/dowhile loop.</p>
</dd>
<dt>tname</dt><dd><p>construct name.</p>
</dd>
<dt>texit_label</dt><dd><p>pointer to the symbol table entry for the label of any EXIT statement which
appeared in the DO body; if an EXIT statement did not appear in the body,
a label is created.
When the terminating statement of the dowhile statement is processed,
the do while loop is transformed into:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  top_label:
if (.not. &lt;dowhile expr&gt;) goto exit_label;
&lt;body of dowhile&gt;
goto top_label;
  exit_label:
&lt;statement after dowhile&gt;
</pre></div>
</div>
</dd>
<dt>tcycle_label</dt><dd><p>pointer to the symbol table entry for the label of any CYCLE statement which
appeared in the DO body; 0 if a CYCLE statement did not appear in the body.</p>
</dd>
<dt>top_label</dt><dd><p>pointer to the symbol table entry for the compiler-created label which
represents the top of the loop.</p>
<p>.BE</p>
</dd>
</dl>
<p><em>Forall Loop</em> — .BS</p>
<dl>
<dt>tdo_label</dt><dd><p>0</p>
</dd>
<dt>tdoinfo</dt><dd><p>pointer to the <code class="docutils literal notranslate"><span class="pre">DOINFO</span></code> record for the do/dowhile loop (see below).</p>
</dd>
<dt>tname</dt><dd><p>0</p>
<p>.BE</p>
</dd>
</dl>
<p><em>Block IF</em> — .BS</p>
<dl>
<dt>tdo_label</dt><dd><p>0</p>
</dd>
<dt>tdoinfo</dt><dd><p>0</p>
</dd>
<dt>tname</dt><dd><p>construct name</p>
<p>.BE</p>
</dd>
</dl>
<p><em>Where</em> — .BS</p>
<dl>
<dt>tdo_label</dt><dd><p>0</p>
</dd>
<dt>tdoinfo</dt><dd><p>0</p>
</dd>
<dt>tname</dt><dd><p>construct name</p>
<p>.BE</p>
</dd>
</dl>
<p>For each DO and DOWHILE loop, a <code class="docutils literal notranslate"><span class="pre">DOINFO</span></code> record is created to record
additional information for the construct:</p>
<p><em>DOINFO</em> — .BS</p>
<dl>
<dt>tindex_var</dt><dd><p>pointer to the symbol table entry for the DO index variable (DO loop only).</p>
</dd>
<dt>tinit_expr</dt><dd><p>ast of the initial expression (DO loop only).</p>
</dd>
<dt>tstep_expr</dt><dd><p>ast of the increment expression (DO loop only).</p>
</dd>
<dt>tlimit_expr</dt><dd><p>ast of the increment expression (DO loop only).</p>
</dd>
<dt>tcount</dt><dd><p>ast of the expression which computes the loop count (DO loop only).</p>
<p>.BE</p>
</dd>
</dl>
</div>
<div class="section" id="array-constructor-list">
<h3>Array Constructor List<a class="headerlink" href="#array-constructor-list" title="Permalink to this headline">¶</a></h3>
<p>When an array constructor is parsed, a list of array constructor items
is created.
An item, during parsing, is either an expression or an implied do
construct.
Each item is built in dynamic storage which is released during
end of statement processing.</p>
<p>The format of an array constructor item is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct _acl {
 int              id;
 struct _acl     \*next;
 union {
     struct sst  \*stkp;
     int          ast;
     struct _acl \*aclp;
 } t;
 union {
     DOINFO      \*doinfo;
     INT          count;
 } u;
} ACL;
</pre></div>
</div>
<p>The
<code class="docutils literal notranslate"><span class="pre">next</span></code>
field links together the items.
The
<code class="docutils literal notranslate"><span class="pre">id</span></code>
of an array constructor item while parsing is one of
<code class="docutils literal notranslate"><span class="pre">AC_EXPR</span></code>
and
<code class="docutils literal notranslate"><span class="pre">AC_IDO</span></code>.</p>
<p><em>AC_EXPR</em> — This represent an item which is an expression.
Information from the semantic stack is copied to this entry.
.BS</p>
<dl class="simple">
<dt>tstkp</dt><dd><p>This holds the value of the semantic stack for the expression.
.BE
<em>AC_IDO</em> — This marks the beginning of an implied DO-loop.
.BS</p>
</dd>
<dt>taclp</dt><dd><p>This is a pointer to an array constructor list under the control
of the implied do.</p>
</dd>
<dt>tdoinfo</dt><dd><p>This is a pointer to the
<code class="docutils literal notranslate"><span class="pre">DOINFO</span></code>
record created for the implied do.
.BEOther types of array constructor items are created when the
list is actually processed (after the parsing is complete).
The other fields in the structure are used during this processing.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="processing">
<h2>Processing<a class="headerlink" href="#processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Overview<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The Semantic Analyzer code can be divided into three parts:</p>
<ol class="arabic simple">
<li><p>fBInitialization\*(rf -  The fIsemant_init\*(rf
routine which is called from the compiler
fIinit\*(rf routine to initialize the Semantic Analyzer data items and
allocate space for certain Semantic Analyzer data structures.</p></li>
<li><p>fBsemantic actions\*(rf - The body of the Semantic Analyzer logically
consists of a large switch statement with one case for each production
of the grammar (case labels are created by the parse table
generator utility - see section 4).
Because of the number of productions, the Semantic Analyzer is divided into
4 separate files:
<em>semant</em>
deals with declarations;
<em>semant2</em>
deals with expressions and simple statements;
<em>semant3</em>
deals with allocate statements, conditional statements, branching and call/function statements;
<em>semantio</em>
deals with I/O statements.
Each semantic action is responsible for performing the
processing associated with the particular production.</p></li>
<li><p>fButility routines\*(rf - routines called by the semantic actions to
do such things as
change expression types, perform constant folding, etc.  These
routines are found in the module fIsemutil.c\*(rf.
The module <code class="docutils literal notranslate"><span class="pre">dinit.c</span></code> contains the routines to implement data
initialization statements and is discussed in the chapter.</p></li>
</ol>
<p>The remainder of this section discusses a number of the
important semantic processing issues.</p>
</div>
<div class="section" id="declaration-processing">
<h3>Declaration Processing<a class="headerlink" href="#declaration-processing" title="Permalink to this headline">¶</a></h3>
<p>The base data type of a symbol is kept globally and modified by
length specifiers and <code class="docutils literal notranslate"><span class="pre">KIND</span></code> specifiers.
For example, <code class="docutils literal notranslate"><span class="pre">INTEGER\*2</span></code> will cause the
global data type to be a <code class="docutils literal notranslate"><span class="pre">DT_SINT</span></code>.  When the symbols in the
declaration list are analyzed the global data type is used by default.
Of course the symbol can have its own length specifier, in which case
its data type is chosen accordingly.  For example,
<code class="docutils literal notranslate"><span class="pre">INTEGER\*2</span> <span class="pre">ZIGGY\*1</span></code> will result in the symbol <code class="docutils literal notranslate"><span class="pre">ZIGGY</span></code>
having a data type <code class="docutils literal notranslate"><span class="pre">DT_BINT</span></code>.  Length and <code class="docutils literal notranslate"><span class="pre">KIND</span></code>
specifiers are only
allowed in data type declaration statements.  The statements
<code class="docutils literal notranslate"><span class="pre">DIMENSION</span></code> and <code class="docutils literal notranslate"><span class="pre">COMMON</span></code> are not allowed to use
length specifiers.</p>
<p>Data type declaration statements, <code class="docutils literal notranslate"><span class="pre">DIMENSION</span></code> statements, and
<code class="docutils literal notranslate"><span class="pre">COMMON</span></code> statements can modify a symbol to be an array.  For
example, the symbol <code class="docutils literal notranslate"><span class="pre">ZIGGY</span></code> could be defined as above and then
specified as an array in a <code class="docutils literal notranslate"><span class="pre">DIMENSION</span></code> or <code class="docutils literal notranslate"><span class="pre">COMMON</span></code>
statement later.  The general rule is that the symbol’s type can change
from a simple variable to an array once.  If an attempt is made to change
to an array again an error is flagged.</p>
<p>A declaration problem arises because of intrinsic functions.
When the declaration statement <code class="docutils literal notranslate"><span class="pre">REAL</span> <span class="pre">SIN</span></code> is encountered the
compiler does not know whether the application programmer meant to simply
reaffirm the declaration of the intrinsic function or that they are
declaring a local variable called <code class="docutils literal notranslate"><span class="pre">SIN</span></code>.  It becomes simple if the
symbol <code class="docutils literal notranslate"><span class="pre">SIN</span></code> were declared an array as in <code class="docutils literal notranslate"><span class="pre">REAL</span> <span class="pre">SIN(10)</span></code>,
because this tells the compiler unequivocally that <code class="docutils literal notranslate"><span class="pre">SIN</span></code> is to be
used as a local array.  Likewise, if the compiler encounters the symbol
<code class="docutils literal notranslate"><span class="pre">SIN</span></code> later in a <code class="docutils literal notranslate"><span class="pre">DIMENSION,</span> <span class="pre">COMMON</span></code>, or <code class="docutils literal notranslate"><span class="pre">EQUIVALENCE</span></code>
statement it knows that the symbol <code class="docutils literal notranslate"><span class="pre">SIN</span></code> is to lose its intrinsic
properties.
If none of these events happens then the compiler must wait until the
first reference to the symbol to determine its intended use.</p>
<p>If the following first reference was encountered then the
symbol <code class="docutils literal notranslate"><span class="pre">SIN</span></code> is assumed to be a local variable and the intrinsic
<code class="docutils literal notranslate"><span class="pre">SIN</span></code> will not be available to the application programmer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sin = sqrt(100)
</pre></div>
</div>
<p>If the following statement were encountered as the first reference then the
symbol <code class="docutils literal notranslate"><span class="pre">SIN</span></code> is reaffirmed as the intrinsic <code class="docutils literal notranslate"><span class="pre">SIN</span></code> and the
intrinsic is frozen, that is, it can only be used as an intrinsic in the
current program section.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x = sin(x)
</pre></div>
</div>
</div>
<div class="section" id="interface-blocks">
<h3>Interface Blocks<a class="headerlink" href="#interface-blocks" title="Permalink to this headline">¶</a></h3>
<p>A subprogram for which an interface is explicitly specified is entered
in the same scope (level 0) as the main subprogram and its variables.
Any variables declared, such as the dummy arguments, are entered into the
symbol table at a scope 1 greater than the current scope.
When the <code class="docutils literal notranslate"><span class="pre">END</span></code> statement for the subprogram is seen, the scope
is
<em>popped</em>
(the symbols in scope are removed from the symbol table’s hash table),
thus hiding the symbols declared in the scope from the rest of the
subprogram.
Since subprograms declared in an interface block
do not inherit any information from their
<em>host</em>,
entities, such as the implicit rules and named (parameter) constants
are hidden from the semantic analysis of the interface block.
Hiding the implicit rules is performed by
<em>pushing</em>
the current rules onto a stack
and
<em>references</em>
to outer-scoped parameters are hidden by restricting the scope levels
which can be accessed if in an interface block.</p>
</div>
<div class="section" id="structure-processing">
<h3>Structure Processing<a class="headerlink" href="#structure-processing" title="Permalink to this headline">¶</a></h3>
<p>The top of the structure stack represents the
<code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code> statement currently being parsed and the preceeding stack
entries represent uncompleted <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code> statements that were
interrupted by nested <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code> statements.</p>
<p>The goal of processing a <code class="docutils literal notranslate"><span class="pre">STRUCTURE/END</span> <span class="pre">STRUCTURE</span></code> block of statements
is to create a data type for the structure being declared.  The data type
entry has a pointer to a linked list of structure members and a pointer
to the initializer constant tree for the members that are data initialized
(see “Initializer Constant Tree” section).  The following example will show
how the nesting of structures is handled by the structure stack.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>structure /a/
 integer b /2/
 structure /c/ d
     integer e /3/
 end structure
end structure
</pre></div>
</div>
<p>The data type for structure tag <code class="docutils literal notranslate"><span class="pre">a</span></code> will point to the list of members
<code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code>, and will point to an initializer constant tree
containing the constant <code class="docutils literal notranslate"><span class="pre">2</span></code>.  At the point where structure <code class="docutils literal notranslate"><span class="pre">c</span></code>
is encountered, the state for structure <code class="docutils literal notranslate"><span class="pre">a</span></code> must be saved on the
structure stack so that it is not confused with structure <code class="docutils literal notranslate"><span class="pre">c</span></code>.
Structure <code class="docutils literal notranslate"><span class="pre">c</span></code> has its own member list and initializer constant tree
built and initialized in a new data type of its own.  When the \*(cfEND
STRUCTURE\*(rf for structure <code class="docutils literal notranslate"><span class="pre">c</span></code> is encountered the structure stack is
popped and the processing for structure <code class="docutils literal notranslate"><span class="pre">a</span></code> is continued.</p>
</div>
<div class="section" id="initializer-processing">
<h3>Initializer Processing<a class="headerlink" href="#initializer-processing" title="Permalink to this headline">¶</a></h3>
<p>The Initializer Constant Tree and Initializer Variable List are built as
the Semantic Analyzer processes data initialization statements.
These data structures are passed to the routine <code class="docutils literal notranslate"><span class="pre">dinit</span></code> in the module
<code class="docutils literal notranslate"><span class="pre">dinit.c</span></code> which
matches each variable with a constant and writes the necessary records
to the Data Initialization File.  The Semantic Analyzer is responsible
for handling the various special features of Fortran initializers, such as:</p>
<ul class="simple">
<li><p>repeated constant fields</p></li>
<li><p>whole array initializations</p></li>
<li><p>partial array initializations</p></li>
<li><p>three forms of initialization syntax; <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statements, type declaration
statements, and <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code> statements</p></li>
</ul>
<p>The three forms of data initialization statements are discussed in the
following sections.</p>
<div class="section" id="data-statements">
<h4>DATA Statements<a class="headerlink" href="#data-statements" title="Permalink to this headline">¶</a></h4>
<p>The following <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statement will be used as an example.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INTEGER a, b(5), c(2,4,3)
DATA a, b, c(1,2,3), c(2,3,2) / 3\*1, 5\*4/
</pre></div>
</div>
<p>Data statement processing requires passing both an Initializer
Constant Tree and a Initializer Variable List to the <code class="docutils literal notranslate"><span class="pre">dinit</span></code>
routine.  Processing requires a walk of both the Initializer Constant Tree and
the Initializer Variable List assigning constants to variables.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statement is the only initializing statement that allows
implied <code class="docutils literal notranslate"><span class="pre">DO</span></code>-loops and array element initialization.
Record references are not allowed in <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statements.</p>
<p>In the example the variables <code class="docutils literal notranslate"><span class="pre">a</span></code> and the first 2 elements of
the array <code class="docutils literal notranslate"><span class="pre">b</span></code> will be initialized to the constant 1.  Three elements
of the array <code class="docutils literal notranslate"><span class="pre">b</span></code> and two elements in the array <code class="docutils literal notranslate"><span class="pre">c</span></code>
will be initialized to the constant 4.  Here is the Initializer Constant
Tree and the Initializer Variable List the <code class="docutils literal notranslate"><span class="pre">dinit</span></code> would process.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IVL ---&gt; a ---&gt; b ---&gt; c ---&gt; c

ICT ---&gt; next ---&gt; next
         Term      Term
         3\*1       5\*4
         0         0
</pre></div>
</div>
<p>The entries for <code class="docutils literal notranslate"><span class="pre">c</span></code> will contain AST pointers for array element
referencing.  These AST pointers will be traced back by <code class="docutils literal notranslate"><span class="pre">dinit</span></code>
to determine the array element being initialized.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statement is the only form of data initialization statement
that allows implied DO-loops.  The following example is used to describe the
processing of implied DO-loops.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      DATA ((a(i,j), i=1, 10), j = 21, 30) / 100\*42.0 /

IVL ---&gt; dostartj ---&gt; dostarti ---&gt; a ---&gt; doendi ---&gt; doendj
         j             i
         21            1
         30            10
         1             1

ICT ---&gt; next
         Term
         100\*42.0
         0
</pre></div>
</div>
<p>The values in the <code class="docutils literal notranslate"><span class="pre">IVL</span></code> structures above are actually AST links.
When the array element reference to <code class="docutils literal notranslate"><span class="pre">a</span></code> is encountered, the AST links
are scanned and the array indexes <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> are evaluated.
The offset from the beginning of array <code class="docutils literal notranslate"><span class="pre">a</span></code> is computed so that the
dinit record can be generated.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">doendj</span></code> is encountered, the corresponding <code class="docutils literal notranslate"><span class="pre">dostarti</span></code> is
located.  Then the index variable <code class="docutils literal notranslate"><span class="pre">i</span></code> is incremented by the step
amount and a test is made to see if the upper bound has been exceeded.
If the inner implied DO-loop controlled by index variable <code class="docutils literal notranslate"><span class="pre">i</span></code> does not
exceed its upper bound then we reset the <code class="docutils literal notranslate"><span class="pre">IVL</span></code> pointer back to process
<code class="docutils literal notranslate"><span class="pre">a</span></code> again, this time with an updated index variable <code class="docutils literal notranslate"><span class="pre">i</span></code>.
Later when the index variable <code class="docutils literal notranslate"><span class="pre">i</span></code> does exceed its upper bound we do
not back up, we simply move forward to the <code class="docutils literal notranslate"><span class="pre">doendj</span></code> entry.  Processing
for the outer implied DO-loop is exactly the same as for the inner DO-loop.</p>
</div>
<div class="section" id="type-declaration-initializations">
<h4>Type Declaration Initializations<a class="headerlink" href="#type-declaration-initializations" title="Permalink to this headline">¶</a></h4>
<p>Data initializations can occur within a type declaration statement.  The
following example will be used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INTEGER a(30) /5\*2, 5\*3, 10\*4/, b/1/
</pre></div>
</div>
<p>In this example the array <code class="docutils literal notranslate"><span class="pre">a</span></code> will be initialized with 20 constants;
five locations with 2, five locations with 3, and ten locations with 4.
The variable <code class="docutils literal notranslate"><span class="pre">b</span></code> will be initialized with the constant 1.
Notice that the type declaration statement does two things.
It declares the number of elements in an array and it initializes that array
starting from its base address.</p>
<p>Record references are not allowed with this form of data initialization.
Implied <code class="docutils literal notranslate"><span class="pre">DO</span></code>-loop specifiers are not allowed with this
type of declaration.</p>
<p>In the example above, the \*cfdinit\*(rf routine will be called twice.
An Initializer Variable List is not used.  The variable information is
embedded within the Initializer Constant Tree.  Here is the Initializer
Constant Tree for each call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICT ---&gt; next ---&gt; next ---&gt; next
         Term      Term      Term
         5\*2       5\*3       10\*4
         a         0         0

ICT ---&gt; next
         Term
         1
         b
</pre></div>
</div>
<p>The first ICT will cause the <code class="docutils literal notranslate"><span class="pre">dinit</span></code> routine to begin with the base
address of <code class="docutils literal notranslate"><span class="pre">a</span></code>.  It will write dinit records to initialize the first
two elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> with the constant 2, then since the next ICT
entry does not have a new symbol table pointer entry, the next five constant
3’s will go into <code class="docutils literal notranslate"><span class="pre">a(3),</span> <span class="pre">a(4),</span></code> and <code class="docutils literal notranslate"><span class="pre">a(5)</span></code>.  The remaining ten
constant 4’s are assigned locations similarly.  Notice that it is not a
problem that there are not enough contants to initialize the entire array.
However, too many constants would be a problem.</p>
</div>
<div class="section" id="structure-data-initializations">
<h4>STRUCTURE Data Initializations<a class="headerlink" href="#structure-data-initializations" title="Permalink to this headline">¶</a></h4>
<p>The following <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code> statement will be used as an example.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>structure /s0/
    integer a(40) /10\*5, 10\*10, 10\*15/
    real b(10)
    integer c/6/
end structure
structure /s1/
    integer a, b(30)/30\*42/
    structure /s2/ c
     integer a /42/
    end structure
    real d, e(30)
    record /s0/ f
end structure
record /s1/ r1, r2(30)
</pre></div>
</div>
<p>Structure initializations differ from the other forms of data initializations.
The occurrance of data initialization within a structure statement does not
cause dinit records to be generated.  The dinit records would be generated
when an instance of the structure was declared via the <code class="docutils literal notranslate"><span class="pre">RECORD</span></code>
statement.  This implies that the Initializer Constant Tree for a structure
must not be deallocated during end of statement processing as it does with the
other forms of initialization statements.  It must be kept around until end of
program module processing.  The data type entry for a structure contains a
pointer to the structure’s Initializer Constant Tree.</p>
<p>Structure initializations use the same form of Initializer Constant Tree as
does the Type Declaration Initialization statements.  The structure tag entry
and the structure in the symbol table will have a pointer the structure’s
data type entry.  From this the structure’s Initializer Constant Tree can be
located.</p>
<p>Here are the Initializer Constant Trees for our example.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICT s0
---&gt; next ---&gt; next ---&gt; next ---&gt; next
     Term      Term      Term      Term
     10\*5      10\*10     10\*15     6
     a         0         0         c

ICT s1
---&gt; next ---&gt; next ---------&gt; next
     Term      Subc (ICT s2)   Subc (ICT s0)
     30\*42     ---             ---
     b         c               f

ICT s2
---&gt; next
     Term
     42
     a
</pre></div>
</div>
<p>Notice that the Initializer Constant Tree for structure <code class="docutils literal notranslate"><span class="pre">s1</span></code>
contains references to the Initializer Constant Trees for other structures.
Also, the <code class="docutils literal notranslate"><span class="pre">sptr</span></code> field in an entry contains a symbol table pointer to
a member of a structure.  This is used to get the offset from the beginning of
a structure for a particular member.  For example, to obtain the offset from
the beginning of record <code class="docutils literal notranslate"><span class="pre">r1</span></code> for the member r1.c.a you would first
calculate the offset from the beginning of <code class="docutils literal notranslate"><span class="pre">r1</span></code> to its member
<code class="docutils literal notranslate"><span class="pre">c</span></code>, then add to that the offset from the beginning of
<code class="docutils literal notranslate"><span class="pre">c</span></code> to its member <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Implied <code class="docutils literal notranslate"><span class="pre">DO</span></code>-loops and partial array initialization is not allowed.</p>
</div>
</div>
<div class="section" id="expressions">
<h3>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h3>
<p>When a reduction is made for an arithmetic, character, or logical
operation, such as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;addition&gt; ::= &lt;arith expr&gt; &lt;addop&gt; &lt;term&gt; ,
</pre></div>
</div>
<p>the semantic action code typically performs the following steps:</p>
<ol class="arabic simple">
<li><p>The data types of the operands are checked and AST’s generated
to convert the data type of one or both of the operands if necessary.
Hollerith and non-decimal constants are handled by data type assumption
rather than data type conversion.  Both of the operands would be converted
for the case where one operand is doubleprecision and the other operand
is complex.  In this case both operands are converted to doublecomplex.</p></li>
<li><p>Each operand is checked to see if one requires a scalar to vector promotion.</p></li>
<li><p>If both operands are constant, the operation is constant folded.
Constant folding is also done in the Expander, but is required
here for array bounds, initializers, and switch labels.</p></li>
<li><p>Otherwise the routine <code class="docutils literal notranslate"><span class="pre">mkexpr</span></code>
is called for each operand, to ensure that
AST’s have been generated.</p></li>
<li><p>The AST for the operation is added.</p></li>
<li><p>The stack entry corresponding to the left hand side of the
reduction is set up with the AST pointer to the added AST,
and information on the data type of the expression.</p></li>
</ol>
</div>
<div class="section" id="logical-expressions">
<h3>Logical Expressions<a class="headerlink" href="#logical-expressions" title="Permalink to this headline">¶</a></h3>
<p>A <em>logical expression</em> is one of the form
<code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">.or.</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">.and.</span> <span class="pre">e2</span></code>, or the negation
operator <code class="docutils literal notranslate"><span class="pre">.not.</span> <span class="pre">e1</span></code>.</p>
</div>
<div class="section" id="array-constructors">
<h3>Array Constructors<a class="headerlink" href="#array-constructors" title="Permalink to this headline">¶</a></h3>
<p>After an array constructor list created during parsing, the list
is analyzed by the function
<code class="docutils literal notranslate"><span class="pre">mk_constructor()</span></code>.
The result of this function is a semantic stack entry
of type <code class="docutils literal notranslate"><span class="pre">S_IDENT</span></code> or <code class="docutils literal notranslate"><span class="pre">S_ACONST</span></code>.
In either case, an array temporary is created which represents the
value of the constructor.
In the former case, code is generated to define the values of the
temporary; in the latter case, enough information is saved so that
data initialization records are created when (if) the constructor
is actually referenced.</p>
<p>The first step in
<code class="docutils literal notranslate"><span class="pre">mk_constructor()</span></code>
is to compute the size of the constructor.
A side-effect of this step is to determine if the temporary can
be data initialized.
Data initialization will occur only if the following criteria are met:</p>
<ol class="arabic simple">
<li><p>implied do’s are not present and all of the items are constants, or</p></li>
<li><p>the context requires an array constant,
implied do’s with constant bounds are present,
the expressions under the control of the implied do’s will yield constants,
and all other items are constants.</p></li>
</ol>
</div>
<div class="section" id="intrinsic-processing">
<h3>Intrinsic Processing<a class="headerlink" href="#intrinsic-processing" title="Permalink to this headline">¶</a></h3>
<p>Intrinsic functions are supplied by the processor and have a special meaning.
Generic names simplify the referencing of specific intrinsic functions.
They allow the function argument to be of any type and provide a mapping
to the specific intrinsic function based on the data type of the argument.</p>
<p>Generic names cannot be used to pass an intrinsic function as an actual
argument.  Specific intrinsic names can be passed as an argument only if
they have been confirmed as intrinsics (see below).  If not confirmed,
then they are treated as variables.</p>
<p>An intrinsic name is predefined by the compiler.  The name
can be confirmed as an intrinsic function or can have its intrinsic property
taken away.  If the compiler encounters one of the cases that confirms the
intended use of a symbol as an intrinsic function, then that symbol is
<em>frozen</em> and can only be used to reference that intrinsic
function for the remainder of the program unit.  If the compiler encounters
one of the cases that removes the symbol’s intrinsic property, then that
symbol is redefined and must be used in a manner according to the user’s
overriding definition and cannot be used as an intrinsic function for the
remainder of the program unit.</p>
<p><em>CASE 1: CONTEXTS HAVING NO EFFECT ON INTRINSIC NAMES</em></p>
<ol class="arabic simple">
<li><p>A specific intrinsic name occuring in a type declaration alone, does not
effect the intrinsic name.  If the name is later confirmed as an intrinsic
name then the type declaration has not effect.  If the name is later used in a
context that removes the intrinsic property of the name, then the name takes
on the data type specified in the type declaration encountered earlier.</p></li>
</ol>
<p><em>CASE 2: CONTEXTS CAUSING INTRINSIC CONFIRMATION</em></p>
<ol class="arabic simple">
<li><p>Use of a name in the <code class="docutils literal notranslate"><span class="pre">INTRINSIC</span></code> statement.</p></li>
<li><p>Use of a name that agrees in context and number and type of arguments
with the predefined intrinsic confirms that name as an intrinsic.</p></li>
</ol>
<p><em>CASE 3: CONTEXTS CAUSING INTRINSIC PROPERTY REMOVAL</em></p>
<ol class="arabic simple">
<li><p>In general, use of an intrinsic function name in a non-executable
statement other than the type specification statements removes the
intrinsic property of that name.</p></li>
<li><p>An intrinsic name declared as an array via a type specification statement
removes the intrinsic property of that name.</p></li>
<li><p>The use of a symbol on the left side of an assignment statement removes
a symbol’s intrinisic property if its intrinsic property is not already
confirmed.</p></li>
<li><p>The use of a symbol without the correct number and type of arguments in
an expression removes the symbol’s intrinsic property if its intrinsic
property is not already confirmed.</p></li>
</ol>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td colspan="3"><p>_</p></td>
</tr>
<tr class="row-even"><td colspan="3"><p>s+1EXAMPLESs0</p></td>
</tr>
<tr class="row-odd"><td><p>subroutine a</p></td>
<td><p>subroutine b</p></td>
<td><p>subroutine c</p></td>
</tr>
<tr class="row-even"><td><p>real exp</p></td>
<td><p>integer exp</p></td>
<td><p>integer exp</p></td>
</tr>
<tr class="row-odd"><td><p>x = exp(x)</p></td>
<td><p>x = exp(x)</p></td>
<td><p>x = exp</p></td>
</tr>
<tr class="row-even"><td><p>end</p></td>
<td><p>end</p></td>
<td><p>end</p></td>
</tr>
<tr class="row-odd"><td colspan="3"><p>_</p></td>
</tr>
</tbody>
</table>
<p>In subroutine <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, the type declaration statement
has no effect on
the intrinsic property of symbol <code class="docutils literal notranslate"><span class="pre">exp</span></code>.  In subroutine <code class="docutils literal notranslate"><span class="pre">b</span></code>,
the symbol <code class="docutils literal notranslate"><span class="pre">exp</span></code> will be redefined as an integer variable.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="parser.html">Parser</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="transform.html">Transformer</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>