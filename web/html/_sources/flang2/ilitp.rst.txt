

**********************
X86-32 ILI Definitions
**********************


===========================
Key to ILI Template Listing
===========================

*ILI Operand Types:*

.. code-block:: none

   irlnk

link to previous ili with result type ir.

.. code-block:: none

   splnk

link to previous ili with result type sp.

.. code-block:: none

   dplnk

link to previous ili with result type dp.

.. code-block:: none

   arlnk

link to previous ili with result type ar.

.. code-block:: none

   krlnk

link to previous ili with result type kr.

.. code-block:: none

   qplnk

link to previous ili with result type qp.

.. code-block:: none

   cslnk

link to previous ili with result type cs.

.. code-block:: none

   cdlnk

link to previous ili with result type cd.

.. code-block:: none

   cqlnk

link to previous ili with result type cq.

.. code-block:: none

   128lnk

link to previous ili with result type 128.

.. code-block:: none

   256lnk

link to previous ili with result type 256.

.. code-block:: none

   512lnk

link to previous ili with result type 512.

.. code-block:: none

   x87lnk

link to previous ili with result type x87.

.. code-block:: none

   cx87lnk

link to previous ili with result type cx87.

.. code-block:: none

   lnk

link to previous ili with result type lnk.

.. code-block:: none

   ir

integer register number (for x86-32, one of the general purpose registers).

.. code-block:: none

   sp

floating-point register number.

.. code-block:: none

   dp

double-precision register.

.. code-block:: none

   kr

pair of 32 bit integer registers.

.. code-block:: none

   cs

single(4+4 bytes) precision complex register.

.. code-block:: none

   cd

double(8+8 bytes) precision complex register.

.. code-block:: none

   cq

16x2 bytes complex register.

.. code-block:: none

   qp

16x2 bytes register.

.. code-block:: none

   128

128 bits register.

.. code-block:: none

   256

256 bits register.

.. code-block:: none

   512

512 bits register.

.. code-block:: none

   x87

x87 register.

.. code-block:: none

   cx87

cx87 register.

.. code-block:: none

   ar

Address register (for x86-32, one of the general purpose registers).

.. code-block:: none

   stc

16 bit constant.  May be interpreted as either signed or unsigned depending
on the machine instruction operand which uses it.

.. code-block:: none

   nme

pointer to names table entry for a load or store.

.. code-block:: none

   sym

symbol table pointer.

*ILI Types (1st attribute of each ILI):*

``arth``
   arithmetic operation.

``branch``
   branch operation.

``cons``
   constant.

``load``

``store``

``define``
   register define.

``proc``
   function call.

``move``
   register move.

``other``

*Commutivity attribute (2nd attribute of each ILI):*
.CM comm
Commutative operation.
.CM null
Not commutative.

*ILI result type (3rd attribute of each ILI):*
.RT lnk
no result, but ili is pointed-to by link.
.RT ir
result goes into an integer register.
.RT sp
result goes into a floating-point register.
.RT dp
double-precision floating-point.
.RT ar
address register result.
.RT trm
this ili does not produce a value and cannot be pointed to by any
link operand of another ili.

*Other ILI Attributes:*
.IA dom
specifies that this ili is a dominator ili.
.IA cse
specifies that this ili is a candidate for constant subexpression elimination.
An ili is not allowed to have both the cse and the dom attributes.
.IA ssenme
indicates that this is an sse operation with operand 1 an arlnk field and
operand 3 a nme field.




===============
ILI Definitions
===============

``ICON``
   32-bit integer constant.
   The value is pulled from the CONVAL2 field of sym.

   *Attributes*: cons null ir cse
   .CG move "mov" 'l'

``ACON``
   Load address constant into address register.
   \'sym' must be a symtab ptr to an address constant.

   *Attributes*: cons null ar cse
   .CG notAILI

``ACON_PIC_EXTRN``
   Address constant used for PIC generation.  It represents the load
   of the address of an external variable from the GOT table.
   \'sym' is the symbol table pointer for the external variable, NOT
   an address constant symbol.

   *Attributes*: cons null ar cse
   .CG CGonly "mov" 'l' asm_special

#. **ACON_STATIC** sym    *Type*: *sym*

   Represents the address of a static or external variable, with optional
   32-bit signed integer offset.  The first sym points to a static or external
   variable, or a label, and the second to a symbol table 32-bit integer constant.

   *Attributes*: cons null ar cse
   .CG CGonly "lea" 'l'

#. **ACON_AUTO** sym    *Type*: *sym*

   The address of a stack variable, the first sym is a stack variable and the
   second is a 32-bit integer constant.

   *Attributes*: cons null ar cse
   .CG CGonly "lea" 'l'

``KCON``
   64-bit integer constant.  'sym' is a symbol table constant of type
   DT_INT or DT_INT8.

   *Attributes*: cons null kr cse
   .CG notAILI 'q'

``SCMPLXCON``
   Single-precision complex constant.

   *Attributes*: cons null cs cse
   .CG "movsd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``DCMPLXCON``
   Double-precision complex constant.

   *Attributes*: cons null cd cse
   .CG "movapd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **ACEXT** nme    *Type*: *sym*

   Label address.
   \'sym' is address constant for label symbol.
   \'nme' is zero.

   *Attributes*: cons null ar cse
   .CG "mov"

``FCON``
   Single-precision floating-point constant.

   *Attributes*: cons null sp cse
   .CG "movss" move

``DCON``
   Double-precision floating-point constant.

   *Attributes*: cons null dp cse
   .CG "movsd" move

#. **LD** nme stc    *Type*: *arlnk*

   \'arlnk' points to an address expression.

   \'nme' points to the names table entry of the variable being referenced.

   \'stc' size modifier of the memory operation - one of the MSZ\_ macros
   defined in ili.h.
   For the code generator, possible values are:
           MSZ_SBYTE	signed byte
           MSZ_UBYTE	unsigned byte
           MSZ_SHWORD	signed half-word
           MSZ_UHWORD	unsigned half-word
           MSZ_SWORD	signed word (32-bit)
           MSZ_UWORD	unsigned word

   *Attributes*: load null ir
   .CG "mov" move

#. **LDSP** nme stc    *Type*: *arlnk*

   Load single-precision floating value.  'stc' is not used.

   *Attributes*: load null sp
   .CG "movss" move

#. **LDDP** nme stc    *Type*: *arlnk*

   Load double precision value.  'stc' is not used.

   *Attributes*: load null dp
   .CG "movsd" move

#. **LDSCMPLX** nme stc    *Type*: *arlnk*

   Load single precision complex value.  'stc' is not used.

   *Attributes*: load null cs
   .CG "movsd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LDDCMPLX** nme stc    *Type*: *arlnk*

   Load double precision complex value.  'stc' is not used.

   *Attributes*: load null cd
   .CG "movups" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LDQ** nme stc    *Type*: *arlnk*

   Load m128 value.  'stc' is not used.

   *Attributes*: load null dp
   .CG "movapd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LDQU** nme stc    *Type*: *arlnk*

   Load unaligned m128 value.  'stc' is not used.

   *Attributes*: load null dp
   .CG "movupd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LD256** nme stc    *Type*: *arlnk*

   Load m256 value.  'stc' is not used.
   Will generate the aligned case for LD256.

   *Attributes*: load null dp
   .CG "movapd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LD256A** nme stc    *Type*: *arlnk*

   Load aligned m256 value.  'stc' is not used.
   Will generate the aligned case for LD256.

   *Attributes*: load null dp
   .CG notAILI

#. **LD256U** nme stc    *Type*: *arlnk*

   Load unaligned m256 value.  'stc' is not used.

   *Attributes*: load null dp
   .CG "movupd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2



#. **LDA** nme    *Type*: *arlnk*

   Load address register from memory location whose address
   is represented by op1.
   For x86-32 compilers, LDA's are replaced by LD's by cgoptim1.

   *Attributes*: load null ar
   .CG notAILI

#. **LDKR** nme stc    *Type*: *arlnk*

   Load 64 bit integer value into register pair.  'stc' is not used.

   *Attributes*: load null kr
   .CG notAILI 'q'

``INEG``
   Signed integer32 negate.

   *Attributes*: arth null ir cse
   .CG memdest ccarith "neg" 'l'

``UINEG``
   Unsigned integer32 negate.

   *Attributes*: arth null ir cse
   .CG notCG replaceby INEG

``KNEG``
   Signed integer64 negate.  (note - don't allow the memdest optimization)

   *Attributes*: arth null kr cse
   .CG notAILI 'q'

``UKNEG``
   Unsigned integer64 negate.

   *Attributes*: arth null kr cse
   .CG notCG replaceby KNEG

``FNEG``
   Single-precision floating-point negate.

   *Attributes*: arth null sp cse
   .CG notAILI

``SCMPLXNEG``
   Single-precision complex negate.

   *Attributes*: arth null cs cse
   .CG notAILI

``DCMPLXNEG``
   Double-precision complex negate.

   *Attributes*: arth null cd cse
   .CG notAILI

#. **FXOR** splnk    *Type*: *splnk*

   May be used to implement FNEG operation.  This operation is non-commutative so
   we can ensure that a memory operand is not used.

   *Attributes*: arth null sp cse
   .CG notCG "xorps" sse_avx

``DNEG``
   Double-precision negate.

   *Attributes*: arth null dp cse
   .CG notAILI

#. **SCMPLXXOR** cslnk    *Type*: *cslnk*

   This only appears in the LILIs and AILIs, not in shared ILIs.  It is
   generated in cgoptim1.c:lili_peephole_opts_2() by transforming
   SCMPLXNEG( op1 ) into an SCMPLXXOR LILI in order to negate 'op1' by
   XORing its sign bits with 1.  This ILI is specified as non-commutative
   (i.e. 'null', not 'comm') for reasons explained in that function.

   *Attributes*: arth null cs cse
   .CG CGonly "xorps" sse_avx

#. **DCMPLXXOR** cdlnk    *Type*: *cdlnk*

   This only appears in the LILIs and AILIs, not in shared ILIs.  It is
   generated in cgoptim1.c:lili_peephole_opts_2() by transforming
   DCMPLXNEG( op1 ) into a DCMPLXXOR LILI in order to negate 'op1' by
   XORing its sign bits with 1.  This ILI is specified as non-commutative
   (i.e. 'null', not 'comm') for reasons explained in that function.

   *Attributes*: arth null cd cse
   .CG CGonly "xorpd" sse_avx

``SCMPLXCONJG``
   Single-precision complex conjugate.

   *Attributes*: arth null cs cse
   .CG "xorps"

``DCMPLXCONJG``
   Double-precision complex conjugate.

   *Attributes*: arth null cd cse
   .CG "xorpd"

#. **DXOR** dplnk    *Type*: *dplnk*

   May be used to implement DNEG operation.

   *Attributes*: arth null dp cse
   .CG notCG "xorpd" sse_avx

``IABS``
   Integer absolute value.  Expanded into shift-xor-sub sequence.

   *Attributes*: arth null ir cse
   .CG notCG

``KABS``
   Integer64 absolute value.  Shift-xor-sub AILI sequence is generated.

   *Attributes*: arth null kr cse
   .CG notAILI 'q'

``FABS``
   Real (single-precision) absolute value.

   *Attributes*: arth null sp cse
   .CG notAILI

#. **FAND** splnk    *Type*: *splnk*

   Used to implement FABS operation.  This operation is non-commutative so
   we can ensure that a memory operand is not used.

   *Attributes*: arth null sp cse
   .CG "andps" sse_avx

``DABS``
   Double precision absolute value.

   *Attributes*: arth null dp cse
   .CG notAILI

#. **DAND** dplnk    *Type*: *dplnk*

   Used to implement DABS operation.

   *Attributes*: arth null dp cse
   .CG CGonly "andpd" sse_avx

``NOT``
   32 bit bitwise not.

   *Attributes*: arth null ir cse
   .CG memdest "not" 'l'

``UNOT``
   Unsigned bitwise negation of 32 bit bitwise not.

   *Attributes*: arth null ir cse
   .CG notCG replaceby NOT

``KNOT``
   64 bit bitwise not.

   *Attributes*: arth null kr cse
   .CG memdest notAILI 'q'

``UKNOT``
   64 bit bitwise not.

   *Attributes*: arth null kr cse
   .CG notCG replaceby KNOT

``FSQRT``
   Single-precision floating-point square root.

   *Attributes*: arth null sp cse
   .CG "sqrtss"

``DSQRT``
   Double-precision square root.

   *Attributes*: arth null dp cse
   .CG "sqrtsd"

``RCPSS``
   Single-precision approximation to reciprocal.

   *Attributes*: arth null sp cse
   .CG "rcpss"

``RSQRTSS``
   Single-precision approximation to reciprocal square root.

   *Attributes*: arth null sp cse
   .CG "rsqrtss"

#. **CMPNEQSS** splnk    *Type*: *splnk*

   Used for single-precision square root approximation.

   *Attributes*: arth null sp cse
   .CG "cmpneqss" sse_avx

``FNSIN``
   Utility ili: only referenced by the 'alt' field of an FSIN ili;
   always points to an FSINCOS ili.

   *Attributes*: arth null sp cse
   .CG notAILI

``DNSIN``
   Utility ili: only referenced by the 'alt' field of an DSIN ili;
   always points to an DSINCOS ili.

   *Attributes*: arth null dp cse
   .CG notAILI

``FSIN``
   Single precision floating point sine.  Implemented as a library call (by CG).

   *Attributes*: arth null sp cse
   .CG notAILI

``DSIN``
   Double precision sine.  Implemented as a library call (by CG).

   *Attributes*: arth null dp cse
   .CG notAILI

``FNCOS``
   Utility ili: only referenced by the 'alt' field of an FCOS ili;
   always points to an FSINCOS ili.

   *Attributes*: arth null sp cse
   .CG notAILI

``DNCOS``
   Utility ili: only referenced by the 'alt' field of an DCOS ili;
   always points to an DSINCOS ili.

   *Attributes*: arth null dp cse
   .CG notAILI

``FCOS``
   Single precision floating point cosine.  Implemented as library call (by CG).

   *Attributes*: arth null sp cse
   .CG notAILI

``DCOS``
   Double precision cosine.  Implemented as library call (by CG).

   *Attributes*: arth null dp cse
   .CG notAILI

``FSINCOS``
   Used to implement SINCOS optimization (single precision).  Implemented as
   a library call (by CG).

   *Attributes*: arth null sp cse
   .CG notAILI

``DSINCOS``
   Used to implement SINCOS optimization (double precision).  Implemented as
   a library call (by CG).

   *Attributes*: arth null dp cse
   .CG notAILI

``FTAN``
   Single-precision floating-point tangent.

   *Attributes*: arth null sp cse
   .CG notCG

``DTAN``
   Double-precision tangent.

   *Attributes*: arth null dp cse
   .CG notCG

``FLOG``
   Single-precision floating-point natural logarithm.

   *Attributes*: arth null sp cse
   .CG notCG

``DLOG``
   Double-precision natural logarithm.

   *Attributes*: arth null dp cse
   .CG notCG

``FLOG10``
   Single-precision floating-point common logarithm.

   *Attributes*: arth null sp cse
   .CG notCG

``DLOG10``
   Double-precision common logarithm.

   *Attributes*: arth null dp cse
   .CG notCG

``FEXP``
   Single-precision floating-point exponential.

   *Attributes*: arth null sp cse
   .CG notCG

``DEXP``
   Double-precision exponential.

   *Attributes*: arth null dp cse
   .CG notCG

``FACOS``
   Single-precision floating-point arccosine.

   *Attributes*: arth null sp cse
   .CG notCG

``DACOS``
   Double-precision  arccosine.

   *Attributes*: arth null dp cse
   .CG notCG

``FASIN``
   Single-precision floating-point arcsine.

   *Attributes*: arth null sp cse
   .CG notCG

``DASIN``
   Double-precision  arcsine.

   *Attributes*: arth null dp cse
   .CG notCG

``FATAN``
   Single-precision floating-point arctangent.

   *Attributes*: arth null sp cse
   .CG notCG

``DATAN``
   Double-precision  arctangent.

   *Attributes*: arth null dp cse
   .CG notCG

#. **FATAN2** splnk    *Type*: *splnk*

   Single-precision floating-point two-argument arctangent.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DATAN2** dplnk    *Type*: *dplnk*

   Double-precision two-argument arctangent.

   *Attributes*: arth null dp cse
   .CG notCG

``FSINH``
   Single-precision floating-point hyperbolic sin

   *Attributes*: arth null sp cse
   .CG notCG

``DSINH``
   Double-precision hyperbolic sin

   *Attributes*: arth null dp cse
   .CG notCG

``FCOSH``
   Single-precision floating-point hyperbolic cos

   *Attributes*: arth null sp cse
   .CG notCG

``DCOSH``
   Double-precision hyperbolic cos

   *Attributes*: arth null dp cse
   .CG notCG

``FTANH``
   Single-precision floating-point hyperbolic tan

   *Attributes*: arth null sp cse
   .CG notCG

``DTANH``
   Double-precision hyperbolic tan

   *Attributes*: arth null dp cse
   .CG notCG

#. **FNEWT** splnk splnk    *Type*: *splnk*

   Single-precision floating-point multiply used for single divides.
   Not used by the x86-32 compilers.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DNEWT** dplnk dplnk    *Type*: *dplnk*

   Double-precision floating-point multiply used for double divides.
   Not used by the x86-32 compilers.

   *Attributes*: arth null dp cse
   .CG notCG

``NINT``
   Real NINT.

   *Attributes*: arth null ir cse
   .CG notCG

``IDNINT``
   Double NINT.

   *Attributes*: arth null ir cse
   .CG notCG

#. **ISIGN** irlnk    *Type*: *irlnk*

   Integer sign intrinsic.

   *Attributes*: arth null ir cse
   .CG notCG

#. **SIGN** splnk    *Type*: *splnk*

   Real sign.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DSIGN** dplnk    *Type*: *dplnk*

   Double sign.

   *Attributes*: arth null dp cse
   .CG notCG

#. **IDIM** irlnk    *Type*: *irlnk*

   Integer dim intrinsic.

   *Attributes*: arth null ir cse
   .CG  notCG

#. **FDIM** splnk    *Type*: *splnk*

   Real dim.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DDIM** dplnk    *Type*: *dplnk*

   Double dim.

   *Attributes*: arth null dp cse
   .CG notCG

``FFLOOR``
   Real FLOOR.

   *Attributes*: arth null sp cse
   .CG "roundss" sse_avx

``DFLOOR``
   Double FLOOR.

   *Attributes*: arth null dp cse
   .CG "roundsd" sse_avx

``FCEIL``
   Real CEILING.

   *Attributes*: arth null sp cse
   .CG "roundss" sse_avx

``DCEIL``
   Double CEILING.

   *Attributes*: arth null dp cse
   .CG "roundsd" sse_avx

``AINT``
   Single precision trunction.

   *Attributes*: arth null sp cse
   .CG notAILI

``DINT``
   Double precision trunction.

   *Attributes*: arth null dp cse
   .CG notAILI

``SCMPLXEXP``
   Single-precision complex exponential.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXEXP``
   Double-precision complex exponential.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXCOS``
   Single-precision complex cosine.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXCOS``
   Double-precision complex cosine.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXSIN``
   Single-precision complex sine.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXSIN``
   Double-precision complex sine.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXTAN``
   Single-precision complex tangent.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXTAN``
   Double-precision complex tangent.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXACOS``
   Single-precision complex arccosine.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXACOS``
   Double-precision complex arccosine.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXASIN``
   Single-precision complex arcsine.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXASIN``
   Double-precision complex arcsine.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXATAN``
   Single-precision complex arctangent.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXATAN``
   Double-precision complex arctangent.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXCOSH``
   Single-precision complex hyperbolic cos.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXCOSH``
   Double-precision complex hyperbolic cos.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXSINH``
   Single-precision complex hyperbolic sin.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXSINH``
   Double-precision complex hyperbolic sin.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXTANH``
   Single-precision complex hyperbolic tan.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXTANH``
   Double-precision complex hyperbolic tan.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXLOG``
   Single-precision complex natural logarithm.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXLOG``
   Double-precision complex natural logarithm.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXSQRT``
   Single-precision complex square root.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXSQRT``
   Double-precision complex square root.

   *Attributes*: arth null cd cse
   .CG notCG

#. **SCMPLXPOW** cslnk    *Type*: *cslnk*

   Single-precision complex raised to a single-precision complex power.

   *Attributes*: arth null cs cse
   .CG notCG

#. **DCMPLXPOW** cdlnk    *Type*: *cdlnk*

   Double-precision complex raised to a double-precision complex power.

   *Attributes*: arth null cd cse
   .CG notCG

#. **SCMPLXPOWI** irlnk    *Type*: *cslnk*

   Single-precision complex raised to an integer power.

   *Attributes*: arth null cs cse
   .CG notCG

#. **DCMPLXPOWI** irlnk    *Type*: *cdlnk*

   Double-precision complex raised to an integer power.

   *Attributes*: arth null cd cse
   .CG notCG

#. **SCMPLXPOWK** krlnk    *Type*: *cslnk*

   Single-precision complex raised to an integer power.

   *Attributes*: arth null cs cse
   .CG notCG

#. **DCMPLXPOWK** krlnk    *Type*: *cdlnk*

   Double-precision complex raised to an integer power.

   *Attributes*: arth null cd cse
   .CG notCG

``ITOUI``
   Integer to unsigned integer conversion.
   Treated as a nop by cglinear.

   *Attributes*: arth null ir cse
   .CG notCG

``UITOI``
   Unsigned integer to integer conversion.
   Treated as a nop by cglinear.

   *Attributes*: arth null ir cse
   .CG notCG

``IKMV``
   Move an signed integer value to a register pair with sign extension.
   Used for I to K and I to UK conversions.

   *Attributes*: move null kr cse
   .CG notAILI 'q'

``UIKMV``
   Move an unsigned integer register to a register pair.

   *Attributes*: move null kr cse
   .CG notAILI 'q'

``KIMV``
   Move a value in a register pair to an integer register with truncation.
   Used also for K to UI, UK to I, and UK to UI conversions.

   *Attributes*: move null ir cse
   .CG notAILI 'l'

``IAMV``
   Move an integer reg into an address reg.
   Treated as a nop by cglinear.

   *Attributes*: move null ar cse
   .CG notCG

``AIMV``
   Move an address register to a integer register.
   Treated as a nop by cglinear.

   *Attributes*: move null ir cse
   .CG notCG

``KAMV``
   Move an 64 bit integer reg into an address reg.

   *Attributes*: move null ar cse
   .CG notCG replaceby KIMV

``AKMV``
   Move an address register to a register pair (no sign extension).

   *Attributes*: move null kr cse
   .CG notCG replaceby UIKMV

``MOVSB``
   Load signed byte into 32 bit register.

   *Attributes*: move null ir
   .CG CGonly asm_special "movsb" 'l'

``MOVZB``
   Load unsigned byte into 32 bit register.

   *Attributes*: move null ir
   .CG CGonly asm_special "movzb" 'l'

``MOVSW``
   Load signed halfword into 32 bit register.

   *Attributes*: move null ir
   .CG CGonly asm_special "movsw" 'l'

``MOVZW``
   Load unsigned halfword into 32 bit register.

   *Attributes*: move null ir
   .CG CGonly asm_special "movzw" 'l'

``FLOAT``
   Integer to single-precision floating-point conversion.

   *Attributes*: arth null sp cse
   .CG "cvtsi2ss" 'l'

``FLOATU``
   Unsigned integer to single-precision floating-point conversion.
   Implemented by library function. (?)

   *Attributes*: arth null sp cse
   .CG notCG

``FLOATK``
   Integer64 to single-precision real conversion.

   *Attributes*: arth null sp cse
   .CG notCG

``FLOATUK``
   Unsigned integer64 to single-precision real conversion.

   *Attributes*: arth null sp cse
   .CG notCG

``DFLOAT``
   Integer to double-precision conversion.

   *Attributes*: arth null dp cse
   .CG "cvtsi2sd" 'l'

``DFLOATU``
   Unsigned integer to double-precision conversion.

   *Attributes*: arth null dp cse
   .CG notCG

``DFLOATK``
   Integer64 to double-precision conversion.

   *Attributes*: arth null dp cse
   .CG notCG

``DFLOATUK``
   Unsigned integer64 to double-precision conversion.

   *Attributes*: arth null dp cse
   .CG notCG

``FIX``
   Single precision floating-point to integer conversion.

   *Attributes*: arth null ir cse
   .CG "cvttss2si" 'l'

``UFIX``
   Single precision floating-point to unsigned integer conversion.
   Implemented by a library function.

   *Attributes*: arth null ir
   .CG notCG

``FIXK``
   Single precision floating-point to integer64 conversion.
   Implemented by a library function.

   *Attributes*: arth null kr cse
   .CG notCG

``FIXUK``
   Single precision to unsigned integer64 conversion.
   Implemented by a library function.

   *Attributes*: arth null kr cse
   .CG notCG

``DFIX``
   Double-precision to integer conversion.

   *Attributes*: arth null ir cse
   .CG "cvttsd2si" 'l'

``DFIXU``
   Double precision to unsigned integer conversion.
   Implemented by a library function.

   *Attributes*: arth null ir cse
   .CG notCG

``DFIXK``
   Double-precision floating-point to integer64 conversion.
   Implemented by a library function.

   *Attributes*: arth null kr cse
   .CG notCG

``DFIXUK``
   Double-precision floating-point to unsigned integer64 conversion.
   Implemented by a call to a library function.

   *Attributes*: arth null kr cse
   .CG notCG

``SNGL``
   Double-precision to single conversion.

   *Attributes*: arth null sp cse
   .CG "cvtsd2ss"

``DBLE``
   Single to double-precision conversion.

   *Attributes*: arth null dp cse
   .CG "cvtss2sd"

#. **PSNGL** xmm nme    *Type*: *arlnk*

   Convert 2 double-precision floating-point values from memory location
   denoted by arlnk into 2 single-precision floating-point values into
   the low 64-bits of the xmm register denoted by xmm.

   *Attributes*: other null trm ssenme
   .CG terminal "cvtpd2ps" ssedp*vector* lat(10)



#. **PDBLE** xmm nme    *Type*: *arlnk*

   Convert 2 single-precision floating-point values from memory location
   denoted by arlnk into 2 double-precision floating-point values into
   the xmm register denoted by xmm.

   *Attributes*: other null trm ssenme
   .CG terminal "cvtps2pd" ssedp*double* lat(5)



#. **PSNGLX** xmm    *Type*: *xmm*

   Convert 2 double-precision floating-point values in xmm1 into
   2 single-precision floating-point values into the
   low-order 64-bits of the xmm register denoted by xmm2.

   *Attributes*: other null trm
   .CG terminal "cvtpd2ps" ssedp*vector* lat(8)



#. **PDBLEX** xmm    *Type*: *xmm*

   Convert 2 single-precision floating-point values from the low
   64-bits of xmm1 into 2 double-precision floating-point values
   into the xmm register denoted by xmm2.

   *Attributes*: other null trm
   .CG terminal "cvtps2pd" ssedp*double* lat(3)



``IR2SP``
   Move integer to xmm register without floating.

   *Attributes*: arth null sp cse
   .CG 'l' asm_special

``KR2SP``
   To be eliminated?

   *Attributes*: arth null sp
   .CG notCG

``KR2DP``
   Transfer a value from a integer64 register to a dp register
   (no conversion performed).

   *Attributes*: arth null dp
   .CG notAILI

``KR2CS``
   Transfer a value from a integer64 register to a dp register
   (no conversion performed).

   *Attributes*: arth null cs
   .CG notAILI

``SP2IR``
   Move single-precision floating-point value to integer register without
   conversion.

   *Attributes*: arth null ir cse
   .CG 'l' asm_special

``SP2KR``
   Not used.

   *Attributes*: arth null kr
   .CG notCG

``DP2KR``
   Transfer a value from a double floating-point register to integer64 register.
   (no conversion performed).

   *Attributes*: arth null kr
   .CG notAILI 'q'

``CS2KR``
   Transfer a value from a double floating-point register to integer64 register.
   (no conversion performed).

   *Attributes*: arth null kr
   .CG notAILI 'q'

#. **ROTL** irlnk    *Type*: *irlnk*


   *Attributes*: arth null ir cse
   .CG ccarith "rol" 'l'

#. **ROTR** irlnk    *Type*: *irlnk*


   *Attributes*: arth null ir cse
   .CG ccarith "ror" 'l'

#. **IADD** irlnk    *Type*: *irlnk*

   Signed integer addition.

   *Attributes*: arth comm ir cse
   .CG memdest ccarith "add" 'l'

#. **UIADD** irlnk    *Type*: *irlnk*

   Unsigned integer addition.

   *Attributes*: arth comm ir cse
   .CG memdest ccarith "add" 'l'

#. **KADD** krlnk    *Type*: *krlnk*

   Signed integer64 addition.  Implemented by IADD/ADC combination.

   *Attributes*: arth comm kr cse
   .CG memdest notAILI 'q'

#. **UKADD** krlnk    *Type*: *krlnk*

   Unsigned integer64 addition.

   *Attributes*: arth comm kr cse
   .CG notCG replaceby KADD

``ADC``
   Signed integer addition with carry.

   *Attributes*: arth comm ir cse
   .CG CGonly "adc" 'l' ccmod

#. **AADD** arlnk stc    *Type*: *arlnk*

   Add two address register values.
   The stc operand is not used by the x86-32 code generator.

   *Attributes*: arth null ar cse
   .CG notCG replaceby IADD

#. **FADD** splnk    *Type*: *splnk*

   Single-precision floating-point addition.

   *Attributes*: arth comm sp cse
   .CG "addss" sse_avx

#. **DADD** dplnk    *Type*: *dplnk*

   Double-precision floating-point addition.

   *Attributes*: arth comm dp cse
   .CG "addsd" sse_avx

#. **SCMPLXADD** cslnk    *Type*: *cslnk*

   Single-precision complex addition.

   *Attributes*: arth comm cs cse
   .CG "addps" sse_avx*double* fadd lat(5:7)



#. **DCMPLXADD** cdlnk    *Type*: *cdlnk*

   Double-precision complex addition.

   *Attributes*: arth comm cd cse
   .CG "addpd" sse_avx*double* fadd lat(5:7)



#. **ISUB** irlnk    *Type*: *irlnk*

   Signed 32-bit integer subtraction.

   *Attributes*: arth null ir cse
   .CG memdest ccarith "sub" 'l'

#. **UISUB** irlnk    *Type*: *irlnk*

   Unsigned integer subtract.  op1 - op2.

   *Attributes*: arth null ir cse
   .CG memdest ccarith "sub" 'l'

#. **KSUB** krlnk    *Type*: *krlnk*

   Signed integer64 subtraction.  Implemented by ISUB/SBB combination.

   *Attributes*: arth null kr cse
   .CG memdest notAILI 'q'

#. **UKSUB** krlnk    *Type*: *krlnk*

   Unsigned integer64 subtraction.

   *Attributes*: arth null kr cse
   .CG notCG replaceby KSUB

``SBB``
   Signed 32-bit integer subtraction with borrow.

   *Attributes*: arth null ir cse
   .CG CGonly "sbb" 'l' ccmod

#. **ASUB** arlnk stc    *Type*: *arlnk*

   Subtract two address register values.  The stc operand is not used.

   *Attributes*: arth null ar cse
   .CG notCG replaceby ISUB

#. **FSUB** splnk    *Type*: *splnk*

   Single-precision floating-point subtraction.

   *Attributes*: arth null sp cse
   .CG "subss" sse_avx

#. **FSUBR** splnk    *Type*: *splnk*

   Single-precision floating-point subtraction - operands reversed
   (used by llvect.c as a convenience).

   *Attributes*: arth null sp cse
   .CG notCG

#. **DSUB** dplnk    *Type*: *dplnk*

   Double-precision floating-point subtraction.

   *Attributes*: arth null dp cse
   .CG "subsd" sse_avx

#. **SCMPLXSUB** cslnk    *Type*: *cslnk*

   Single-precision complex subtraction.

   *Attributes*: arth null cs cse
   .CG "subps" sse_avx*double* fadd lat(7:5)



#. **DCMPLXSUB** cdlnk    *Type*: *cdlnk*

   Double-precision complex subtraction.

   *Attributes*: arth null cd cse
   .CG "subpd" sse_avx*double* fadd lat(7:5)



#. **IMUL** irlnk    *Type*: *irlnk*

   Integer Multiply.  It'a a bug to give this opcode the ccarith or
   cclogical attribute.

   *Attributes*: arth comm ir cse
   .CG "imul" 'l' ccmod

#. **UIMUL** irlnk    *Type*: *irlnk*

   Unsigned integer multiply. Same as signed.

   *Attributes*: arth comm ir cse
   .CG notCG replaceby IMUL

#. **IMULH** irlnk    *Type*: *irlnk*

   Integer multiply, high 32-bits of product as result

   *Attributes*: arth comm ir cse
   .CG "imul" 'l' ccmod

#. **KMULH** krlnk    *Type*: *krlnk*

   Integer64 Multiply, high 64-bits of product returned.

   *Attributes*: other comm kr cse
   .CG "imul" 'q' ccmod*direct* lat(8)



#. **UIMULH** irlnk    *Type*: *irlnk*

   Integer multiply, high 32-bits of product as result

   *Attributes*: arth comm ir cse
   .CG "mul" 'l' ccmod

#. **KMUL** krlnk    *Type*: *krlnk*

   Integer64 Multiply.  Implemented by library function.

   *Attributes*: arth comm kr cse
   .CG asm_nop

#. **UKMUL** krlnk    *Type*: *krlnk*

   Unsigned integer64 Multiply.  Implemented by library function.

   *Attributes*: arth comm kr cse
   .CG notCG replaceby KMUL

#. **UKMULH** krlnk    *Type*: *krlnk*

   Integer64 Multiply, high 64-bits of product returned.

   *Attributes*: other comm kr cse
   .CG "mul" 'q' ccmod*direct* lat(8)



#. **FMUL** splnk    *Type*: *splnk*

   Single-precision floating-point multiply.

   *Attributes*: arth comm sp cse
   .CG "mulss" sse_avx

#. **DMUL** dplnk    *Type*: *dplnk*

   Double-precision multiply.

   *Attributes*: arth comm dp cse
   .CG "mulsd" sse_avx

#. **SCMPLXMUL** cslnk    *Type*: *cslnk*

   Single-complex multiply.

   *Attributes*: arth comm cs cse
   .CG sse_avx asm_special

#. **DCMPLXMUL** cdlnk    *Type*: *cdlnk*

   Double-complex multiply.

   *Attributes*: arth comm cd cse
   .CG sse_avx asm_special

#. **IDIV** irlnk    *Type*: *irlnk*

   Signed integer divide.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UIDIV** irlnk    *Type*: *irlnk*

   Unsigned integer divide.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KDIV** krlnk    *Type*: *krlnk*

   Signed integer64 divide.

   *Attributes*: arth null kr cse
   .CG notCG

#. **UKDIV** krlnk    *Type*: *krlnk*

   Unsigned integer64 divide.

   *Attributes*: arth null kr cse
   .CG notCG

#. **IDIVZ** irlnk    *Type*: *irlnk*

   Signed integer divide where divide by zero does not fault.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UIDIVZ** irlnk    *Type*: *irlnk*

   Unsigned integer divide where divide by zero does not fault.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KDIVZ** krlnk    *Type*: *krlnk*

   Signed integer64 divide where divide by zero does not fault.

   *Attributes*: arth null kr cse
   .CG notCG

#. **UKDIVZ** krlnk    *Type*: *krlnk*

   Unsigned integer64 divide where divide by zero does not fault.

   *Attributes*: arth null kr cse
   .CG notCG

#. **IDIVZR** irlnk    *Type*: *irlnk*

   Signed integer divide where the remainder is zero

   *Attributes*: arth null ir cse
   .CG notCG

#. **KDIVZR** krlnk    *Type*: *krlnk*

   Signed integer64 divide where the remainder is zero

   *Attributes*: arth null kr cse
   .CG notCG

#. **QUOREM** irlnk    *Type*: *irlnk*

   Represents an integer divide and/or mod operation.  Use of this ili allows
   a single divide instruction to both a divide and mod result.

   *Attributes*: arth null ir cse
   .CG notAILI 'l'

#. **KQUOREM** krlnk    *Type*: *krlnk*

   Represents a long divide and/or mod operation.  Use of this ili allows
   a single divide instruction to both a divide and mod result.

   *Attributes*: arth null kr cse
   .CG notCG

``NIDIV``
   Signed integer divide that points to QUOREM.  Result is in register %eax.

   *Attributes*: arth null ir cse
   .CG "idiv" 'l' ccmod

``NUIDIV``
   Unsigned integer divide that points to QUOREM.  Result is in register %eax.

   *Attributes*: arth null ir cse
   .CG "div" 'l' ccmod

``NKDIV``
   Signed integer64 divide that points to QUOREM.  Result is in register %rax.

   *Attributes*: arth null kr cse
   .CG notCG

``NUKDIV``
   Unsigned integer64 divide that points to QUOREM.  Result is in register %rax.

   *Attributes*: arth null kr cse
   .CG notCG

#. **FDIV** splnk    *Type*: *splnk*

   Single-precision divide.

   *Attributes*: arth null sp cse
   .CG "divss" sse_avx

#. **FDIVR** splnk    *Type*: *splnk*

   Single-precision divide - operands reversed (used by llvect.c
   as a convenience).

   *Attributes*: arth null sp cse
   .CG notCG

#. **DDIV** dplnk    *Type*: *dplnk*

   Double divide.

   *Attributes*: arth null dp cse
   .CG "divsd" sse_avx

#. **SCMPLXDIV** cslnk    *Type*: *cslnk*

   Single precision complex divide.

   *Attributes*: arth null cs cse
   .CG notCG

#. **DCMPLXDIV** cdlnk    *Type*: *cdlnk*

   Double precision complex divide.

   *Attributes*: arth null cd cse
   .CG notCG

#. **MOD** irlnk    *Type*: *irlnk*

   Integer remainder.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UIMOD** irlnk    *Type*: *irlnk*

   Unsigned integer mod.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KMOD** krlnk    *Type*: *krlnk*

   Integer64 remainder.

   *Attributes*: arth null kr
   .CG notCG

#. **KUMOD** krlnk    *Type*: *krlnk*

   Integer64 remainder.

   *Attributes*: arth null kr
   .CG notCG

#. **MODZ** irlnk    *Type*: *irlnk*

   Integer remainder where divide by zero does not fault.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UIMODZ** irlnk    *Type*: *irlnk*

   Unsigned integer mod where divide by zero does not fault.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KMODZ** krlnk    *Type*: *krlnk*

   Integer64 remainder where divide by zero does not fault.

   *Attributes*: arth null kr
   .CG notCG

#. **KUMODZ** krlnk    *Type*: *krlnk*

   Integer64 remainder where divide by zero does not fault.

   *Attributes*: arth null kr
   .CG notCG

``NMOD``
   Integer remainder that points to a QUOREM ili.  Result is in register %edx.

   *Attributes*: arth null ir cse
   .CG "idiv" 'l' ccmod

``NUIMOD``
   Unsigned integer mod that points to QUOREM ili.  Result is in register %edx.

   *Attributes*: arth null ir cse
   .CG "div" 'l' ccmod

``NKMOD``
   Integer remainder that points to a QUOREM ili.  Result is in register %rdx.

   *Attributes*: arth null kr cse
   .CG notCG

``NUKMOD``
   Unsigned integer mod that points to QUOREM ili.  Result is in register %rdx.

   *Attributes*: arth null kr cse
   .CG notCG

#. **FMOD** splnk    *Type*: *splnk*

   Single-precision mod.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DMOD** dplnk    *Type*: *dplnk*

   Double-precision mod.

   *Attributes*: arth null dp cse
   .CG notCG

#. **IMAX** irlnk    *Type*: *irlnk*

   Integer maximum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm ir cse
   .CG asm_special "cmpl" 'l' ccmod

#. **UIMAX** irlnk    *Type*: *irlnk*

   Unsigned integer maximum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm ir cse
   .CG notCG

#. **IMIN** irlnk    *Type*: *irlnk*

   Integer minimum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm ir cse
   .CG asm_special "cmpl" 'l' ccmod

#. **UIMIN** irlnk    *Type*: *irlnk*

   Unsigned integer minimum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm ir cse
   .CG notCG

#. **KMAX** krlnk    *Type*: *krlnk*

   Integer64 maximum value.  Implemented by library function call.

   *Attributes*: arth comm kr cse
   .CG notCG

#. **UKMAX** krlnk    *Type*: *krlnk*

   Unsigned integer64 maximum value.  Implemented by library function call.

   *Attributes*: arth comm kr cse
   .CG notCG

#. **KMIN** krlnk    *Type*: *krlnk*

   Integer64 minimum value.  Implemented by library function call.

   *Attributes*: arth comm kr cse
   .CG notCG

#. **UKMIN** krlnk    *Type*: *krlnk*

   Unsigned integer64 minimum value.  Implemented by library function call.

   *Attributes*: arth comm kr cse
   .CG notCG

#. **FMAX** splnk    *Type*: *splnk*

   Single precision maximum.

   *Attributes*: arth comm sp cse
   .CG "maxss" sse_avx

#. **FMIN** splnk    *Type*: *splnk*

   Single precision minimum.

   *Attributes*: arth comm sp cse
   .CG "minss" sse_avx

#. **DMAX** dplnk    *Type*: *dplnk*

   Double precision maximum.

   *Attributes*: arth comm dp cse
   .CG "maxsd" sse_avx

#. **DMIN** dplnk    *Type*: *dplnk*

   Double precison minimum.

   *Attributes*: arth comm dp cse
   .CG "minsd" sse_avx

#. **JN** splnk    *Type*: *irlnk*

   float bessel_jn

   *Attributes*: arth null sp cse
   .CG notCG

#. **DJN** dplnk    *Type*: *irlnk*

   double bessel_jn

   *Attributes*: arth null dp cse
   .CG notCG

#. **YN** splnk    *Type*: *irlnk*

   float bessel_yn

   *Attributes*: arth null sp cse
   .CG notCG

#. **DYN** dplnk    *Type*: *irlnk*

   double bessel_yn

   *Attributes*: arth null dp cse
   .CG notCG


#. **DFMA** dplnk dplnk    *Type*: *dplnk*

   This opcode is only used in AILIs, not shared or linear ILIs.  It
   represents a scalar double-precision FMA3 or FMA4 instruction which
   computes:
       dest = <sign> (src1 \* src2) <addop> src3

   Either 'src2' or 'src3', but not both, can be a memory operand, and
   the other operands are xmm register operands.  The values of <sign>
   (+/-) and <addop> (+/-) are specified by an 'FMA\_...' flag set in the
   cc field of the AILI.  Since AILIs allow at most 2 source operands,
   this AILI is always immediately preceded by a USE AILI which specifies
   the 'src1' operand.

   *Attributes*: arth null dp
   .CG CGonly asm_special

#. **FFMA** splnk splnk    *Type*: *splnk*

   This is the same as DFMA except that it represents a scalar single
   precision FMA3 or FMA4 instruction.

   *Attributes*: arth null sp
   .CG CGonly asm_special

#. **IPOWI** irlnk    *Type*: *irlnk*

   Integer raised to an integer power.

   *Attributes*: arth null ir cse
   .CG notCG

#. **FPOWI** irlnk    *Type*: *splnk*

   Real raised to an integer power.

   *Attributes*: arth null sp cse
   .CG notCG

#. **FPOWK** krlnk    *Type*: *splnk*

   Real raised to an integer power.

   *Attributes*: arth null sp cse
   .CG notCG

#. **FPOWF** splnk    *Type*: *splnk*

   Real raised to a real power.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DPOWI** irlnk    *Type*: *dplnk*

   Double raised to a integer power.

   *Attributes*: arth null dp cse
   .CG notCG

#. **DPOWK** krlnk    *Type*: *dplnk*

   Double raised to a integer power.

   *Attributes*: arth null dp cse
   .CG notCG

#. **DPOWD** dplnk    *Type*: *dplnk*

   Double raised to a double power.

   *Attributes*: arth null dp cse
   .CG notCG

#. **ICMP** irlnk stc    *Type*: *irlnk*

   Integer compare with result of true or false.
   For C the value of true is 1, and for Fortran, -1.
   \'stc' denotes condition code, as for the ICJMP ili.

   *Attributes*: arth null ir cse
   .CG asm_special "cmpl" 'l' ccmod

#. **UICMP** irlnk stc    *Type*: *irlnk*

   Unsigned integer compare.

   *Attributes*: arth null ir cse
   .CG notAILI 'l'

#. **KCMP** krlnk stc    *Type*: *krlnk*

   Integer64 compare with result of true or false.
   Implemented by library function call.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UKCMP** krlnk stc    *Type*: *krlnk*

   Unsigned integer64 compare with result of true or false.

   *Attributes*: arth null ir cse
   .CG notCG

#. **ACMP** arlnk stc    *Type*: *arlnk*

   Address compare with result of true or false.
   The conditions (stc) are the same as for ICMP.

   *Attributes*: arth null ir cse
   .CG notCG replaceby UICMP

#. **FCMP** splnk stc    *Type*: *splnk*

   Single float compare with result of true or false.
   stc is a floating point condition code: one of the 12 values defined in ili.h.

   *Attributes*: arth null ir cse
   .CG asm_special "ucomiss" ccmod

#. **DCMP** dplnk stc    *Type*: *dplnk*

   Double precision compare with result of true or false.

   *Attributes*: arth null ir cse
   .CG asm_special "ucomisd" ccmod

#. **SCMPLXCMP** dplnk stc    *Type*: *dplnk*

   Single precision complex compare with result of true or false.

   *Attributes*: arth comm ir cse
   .CG asm_special "ucomisd" ccmod

#. **DCMPLXCMP** dplnk stc    *Type*: *dplnk*

   Double precision complex compare with result of true or false.

   *Attributes*: arth comm ir cse
   .CG asm_special "ucomisd" ccmod

#. **ICMPZ** stc    *Type*: *irlnk*

   Integer compare with zero.

   *Attributes*: arth null ir cse
   .CG notAILI 'l'

#. **UICMPZ** stc    *Type*: *irlnk*

   Unsigned integer compare with zero.

   *Attributes*: arth null ir cse
   .CG notAILI 'l'

#. **KCMPZ** stc    *Type*: *krlnk*

   Integer64 compare with zero; returns integer value.
   Implemented by library function call.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UKCMPZ** stc    *Type*: *krlnk*

   Integer64 compare with zero.

   *Attributes*: arth null ir cse
   .CG notCG

#. **ACMPZ** stc    *Type*: *arlnk*

   Address compare with zero.

   *Attributes*: arth null ir cse
   .CG notCG replaceby UICMPZ

#. **FCMPZ** stc    *Type*: *splnk*

   Single float compare with zero; result is TRUE or FALSE.

   *Attributes*: arth null ir cse
   .CG notCG

#. **DCMPZ** stc    *Type*: *dplnk*

   Double precision compare with zero.

   *Attributes*: arth null ir cse
   .CG notCG

#. **TEST** irlnk    *Type*: *irlnk*

   Compare register value with 0.

   *Attributes*: arth comm ir cse
   .CG CGonly "testl" cclogical 'l' asm_special*direct* lat(4:1)



#. **KTEST** krlnk    *Type*: *krlnk*

   Compare register value with 0.  For 64-bit targets only.

   *Attributes*: arth comm ir cse
   .CG notCG

#. **ISELECT** irlnk irlnk    *Type*: *irlnk*

   Select either the 2nd or 3rd operand value based on the comparison
   operation pointed to by the 1st operand.

   *Attributes*: other null ir cse
   .CG notAILI 'l'

#. **KSELECT** krlnk krlnk    *Type*: *irlnk*


   *Attributes*: other null kr cse
   .CG notCG

#. **ASELECT** arlnk arlnk    *Type*: *irlnk*


   *Attributes*: other null ar cse
   .CG notCG replaceby ISELECT

#. **FSELECT** splnk splnk    *Type*: *irlnk*


   *Attributes*: other null sp cse
   .CG notAILI

#. **DSELECT** dplnk dplnk    *Type*: *irlnk*


   *Attributes*: other null dp cse
   .CG notAILI

#. **CSSELECT** cslnk cslnk    *Type*: *irlnk*


   *Attributes*: other null cs cse
   .CG notAILI

#. **CDSELECT** cdlnk cdlnk    *Type*: *irlnk*


   *Attributes*: other null cd cse
   .CG notAILI

#. **AND** irlnk    *Type*: *irlnk*

   Bitwise 32-bit 'and' operation.

   *Attributes*: arth comm ir cse
   .CG memdest cclogical "and" 'l'

#. **KAND** krlnk    *Type*: *krlnk*

   Bitwise 64-bit 'and' operation.

   *Attributes*: arth comm kr
   .CG memdest notAILI 'q'

#. **OR** irlnk    *Type*: *irlnk*

   Bitwise 32-bit 'or' operation.

   *Attributes*: arth comm ir cse
   .CG memdest cclogical "or" 'l'

#. **KOR** krlnk    *Type*: *krlnk*

   Bitwise 64-bit 'or' operation.

   *Attributes*: arth comm kr
   .CG memdest notAILI 'q'

#. **XOR** irlnk    *Type*: *irlnk*

   Bitwise exclusive-or operation.

   *Attributes*: arth comm ir cse
   .CG memdest cclogical "xor" 'l'

#. **LEQV** irlnk    *Type*: *irlnk*

   Bitwise exclusive-or followed by not operation.

   *Attributes*: arth comm ir cse
   .CG memdest cclogical "leqv" 'l'

#. **KXOR** krlnk    *Type*: *krlnk*

   Bitwise 64-bit exclusive-or operation.

   *Attributes*: arth comm kr
   .CG memdest notAILI 'q'

#. **EQV** irlnk    *Type*: *irlnk*


   *Attributes*: arth comm ir cse
   .CG notCG

#. **JISHFT** irlnk    *Type*: *irlnk*

   Shift op1 logically by op2.  Left if op2 is > 0; else right
   (no sign extension).
   This ili only shows up for Fortran, specifically for the JISHFT
   intrinsic.
   If 2nd operand is compile time constant, this ili will have been
   replaced by either a left or right shift ili by the Expander.
   Otherwise, it is implemented as a call to a run-time function.

   *Attributes*: arth null ir cse
   .CG notCG

#. **USHIFT** irlnk    *Type*: *irlnk*

   Shift op1 logically by op2.  Left if op2 is > 0; else right.
   This ili should have been replaced before code generator.

   *Attributes*: arth null ir cse
   .CG notCG

#. **SHIFTA** arlnk    *Type*: *irlnk*

   Shift op1 logically by op2.  Left if op2 is > 0; else right.

   *Attributes*: arth null ir cse
   .CG notCG

#. **USHIFTA** arlnk    *Type*: *irlnk*

   Unsigned shift op1 logically by op2.  Left if op2 is > 0; else right.

   *Attributes*: arth null ir cse
   .CG notCG

#. **LSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 left logically by op2.

   *Attributes*: arth null ir cse
   .CG memdest ccarith shiftop asm_special "shl" 'l'

#. **ULSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 left logically by op2.

   *Attributes*: arth null ir cse
   .CG notCG replaceby LSHIFT

#. **LSHIFTI** stc    *Type*: *irlnk*

   Shift left immediate.   This opcode used only in Code Generator.

   *Attributes*: arth null ir cse
   .CG memdest ccarith shiftop "shl" CGonly 'l'

#. **KLSHIFTI** stc    *Type*: *krlnk*

   Shift left immediate of 64-bit value.

   *Attributes*: arth null kr cse
   .CG notAILI 'q'

#. **RSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 logically right by op2 (sign extended).

   *Attributes*: arth null ir cse
   .CG notCG replaceby ARSHIFT

#. **URSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 logically right by op2 (0 fill).

   *Attributes*: arth null ir cse
   .CG memdest ccarith shiftop asm_special "shr" 'l'

#. **ARSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 arithmetically (sign extended) right by op2.
   Used for right shifts (>> operator) of signed values.

   *Attributes*: arth null ir cse
   .CG memdest ccarith shiftop asm_special "sar" 'l'

#. **KLSHIFT** irlnk    *Type*: *krlnk*

   Left shift of 64-bit value.

   *Attributes*: arth null kr cse
   .CG notAILI 'q'

#. **KURSHIFT** irlnk    *Type*: *krlnk*

   Zero-fill right shift of 64-bit value.

   *Attributes*: arth null kr cse
   .CG notAILI 'q'

#. **KARSHIFT** irlnk    *Type*: *krlnk*

   Sign-extended right shift of 64-bit value.

   *Attributes*: arth null kr cse
   .CG notAILI 'q'

#. **ILEADZI** stc    *Type*: *irlnk*

   8-/16- bit integer LEADZ intrinsic.
   The value, 0 or 1, of the second operand indicates
   8-bit or 16-bit, respectively.

   *Attributes*: arth null ir cse


``ILEADZ``
   32-bit integer LEADZ intrinsic.

   *Attributes*: arth null ir cse
   .CG "lzcnt" 'l'

``KLEADZ``
   64-bit integer LEADZ intrinsic.

   *Attributes*: arth null kr cse
   .CG "lzcnt" 'q'

#. **ITRAILZI** stc    *Type*: *irlnk*

   8-/16- bit integer TRAILZ intrinsic.
   The value, 0 or 1, of the second operand indicates
   8-bit or 16-bit, respectively.

   *Attributes*: arth null ir cse


``ITRAILZ``
   32-bit integer TRAILZ intrinsic.

   *Attributes*: arth null ir cse
   .CG "tzcnt" 'l'

``KTRAILZ``
   64-bit integer TRAILZ intrinsic.

   *Attributes*: arth null kr cse
   .CG "tzcnt" 'q'

#. **IPOPCNTI** stc    *Type*: *irlnk*

   8-/16- bit integer POPCNT intrinsic.
   The value of second operand indicates 8-bit if 0 and 16-bit
   if 1.

   *Attributes*: arth null ir cse


``IPOPCNT``
   32-bit integer POPCNT intrinsic.

   *Attributes*: arth null ir cse
   .CG "popcnt" 'l'

``KPOPCNT``
   64-bit integer POPCNT intrinsic.

   *Attributes*: arth null kr cse
   .CG "popcnt" 'q'

#. **IPOPPARI** stc    *Type*: *irlnk*

   8-/16- bit integer POPPAR intrinsic.
   The value of second operand indicates 8-bit if 0 and 16-bit
   if 1.

   *Attributes*: arth null ir cse


``IPOPPAR``
   32-bit integer POPPAR intrinsic.

   *Attributes*: arth null ir cse


``KPOPPAR``
   64-bit integer POPPAR intrinsic.

   *Attributes*: arth null kr cse


#. **EXTRACT** stc stc    *Type*: *irlnk*

   Note that this ILI is defined for machines with bit field extract
   HW support (e.g. 88000).
   The two stc operand definitions are architecture DEPENDENT.

   *Attributes*: arth null ir cse
   .CG notCG

``JMP``
   Unconditional jump to indicated label.

   *Attributes*: branch null trm dom
   .CG terminal "jmp"

``JMPA``
   Branch indirect.  Fortran only.

   *Attributes*: branch null trm dom
   .CG terminal "jmp" asm_special

#. **JMPM** irlnk sym sym    *Type*: *irlnk*

   Indexed jump from a memory table of jump addresses.
   irlnk1 - integer index expression.

   irlnk2 - table_size

   sym - label for memory table containing addresses

   sym  - default label

   *Attributes*: branch null trm dom
   .CG terminal asm_special 'l'

#. **JMPMK** irlnk sym sym    *Type*: *krlnk*

   Indexed jump using a 64-bit integer as index value.

   *Attributes*: branch null trm dom
   .CG notCG 'q'

#. **JMPT** irlnk    *Type*: *irlnk*

   NOT USED.
   Indexed jump into a table of jump instructions.

   .. line-block::
       irlnk1 - integer index expression. The expression has
              already been normalized to 1 (the value 0 is
              reserved for the "default" jump). If the expression
              is not in the range 1:(n-1) where n is the jump table
              size, the default jump is taken.
       irlnk2 - table_size (includes the default label).
       .AT branch null trm dom
       .CG notCG

       .IL QSWITCH sym lnk stc
       .AT proc null lnk dom
       .CG notCG

       .IL ICJMP irlnk irlnk stc sym
       Integer compare and jump to the label 'sym'
       if the condition, denoted by stc, is true.
       .sp
       Allowed values of stc:
       .sp
           1 = CC_EQ   (jump if equal)
           2 = CC_NE   (jump if not equal)
           3 = CC_LT   (jump if less than)
           4 = CC_GE   (jump if greater than or equal to)
           5 = CC_LE   (jump if less than or equal to)
           6 = CC_GT   (jump if greater than)
       .sp
       .AT branch null trm dom
       .CG terminal notAILI 'l' conditional_branch

       .IL UICJMP irlnk irlnk stc sym
       Unsigned integer compare and jump to the label 'sym'
       if the condition, denoted by stc, is true.
       Conditions same as for ICJMP.
       .AT branch null trm dom
       .CG terminal notAILI 'l' conditional_branch

       .IL KCJMP krlnk krlnk stc sym
       Integer64 compare and jump to the label 'sym' if the condition,
       denoted by stc, is true.
       Implemented by library function call.
       .AT branch null trm dom
       .CG notCG

       .IL UKCJMP krlnk krlnk stc sym
       unsigned integer64 compare and jump to the label 'sym'
       if the condition, denoted by stc, is true.
       .AT branch null trm dom
       .CG notCG

       .IL ACJMP arlnk arlnk stc sym
       Address compare and jump to the label 'sym'
       if the condition, denoted by stc, is true.
       .AT branch null trm dom
       .CG notCG replaceby UICJMP conditional_branch

       .IL FCJMP splnk splnk stc sym
       Single precision compare and jump to the label 'sym'
       if the condition, denoted by stc, is true.
       .AT branch null trm dom
       .CG terminal conditional_branch notAILI

       .IL DCJMP dplnk dplnk stc sym
       Double precision compare and jump to the label 'sym'
       if the condition, denoted by stc, is true.
       .AT branch null trm dom
       .CG terminal conditional_branch notAILI

       .IL ICJMPZ irlnk stc sym
       Integer compare with zero and branch to label 'sym' -
       the allowed values (and meanings) for stc are the same as for the ICJMP ILI.
       .AT branch null trm dom
       .CG terminal notAILI 'l' conditional_branch

       .IL UICJMPZ irlnk stc sym
       Unsigned integer compare with zero and branch to label 'sym' -
       the allowed values (and meanings) for stc are the same as for the ICJMP ILI.
       .AT branch null trm dom
       .CG terminal notAILI 'l' conditional_branch

       .IL LCJMPZ irlnk stc sym
       Logical compare with zero and branch to label 'sym' -
       the allowed values (and meanings) for stc are the same as for the ICJMP ILI.
       .AT branch null trm dom
       .CG notCG replaceby UICJMPZ conditional_branch

       .IL KCJMPZ krlnk stc sym
       Integer64 compare with zero and branch to label 'sym'.
       For EQ or NE conditions, code is generated; otherwise a library call is used.
       .AT branch null trm dom
       .CG terminal notAILI conditional_branch

       .IL UKCJMPZ krlnk stc sym
       Integer64 compare with zero and branch to label 'sym'.
       For EQ or NE conditions, code is generated; otherwise a library call is used.
       .AT branch null trm dom
       .CG terminal notAILI conditional_branch

       .IL ACJMPZ arlnk stc sym
       Address compare with zero and branch to label 'sym' -
       the allowed values (and meanings) for stc are the same as for the ICJMP ILI.
       .AT branch null trm dom
       .CG notCG replaceby UICJMPZ conditional_branch

       .IL FCJMPZ splnk stc sym
       Single compare with zero and branch to label 'sym'.
       .AT branch null trm dom
       .CG notCG conditional_branch

       .IL DCJMPZ dplnk stc sym
       Double compare with zero and branch to label 'sym'.
       .AT branch null trm dom
       .CG notCG conditional_branch

       .IL JCC
       Conditional jump based on immediately preceding compare operation.
       Used only in the AILI.
       .AT branch null trm dom
       .CG CGonly asm_special conditional_branch

       .IL CSEIR irlnk
       Integer register cse (common subexpression). The ILI located by the cse
       ILI is one whose value is to be re-used (the ILI need not be "evaluated").
       This ILI is used when multiple references of an ILM occur in the same
       ILM block.  The CSE ili are treated as a special case by the linearizer,
       and never appear in a linear ili block.
       .AT arth null ir
       .CG notCG

       .IL CSESP splnk
       Single precision register cse.
       .AT arth null sp
       .CG notCG

       .IL CSEDP dplnk
       Double precision register cse.
       .AT arth null dp
       .CG notCG

       .IL CSECS cslnk
       Single precision complex register cse.
       .AT arth null cs
       .CG notCG

       .IL CSECD cdlnk
       Double precision complex register cse.
       .AT arth null cd
       .CG notCG

       .IL CSEAR arlnk
       Address register cse.
       .AT arth null ar
       .CG notCG

       .IL CSEKR krlnk
       Integer64 register cse.
       .AT arth null kr
       .CG notCG

       .IL CSE lnk stc
       Complex cse (common subexpression). The ILI located by the cse
       ILI is one whose value is to be re-used (the ILI need not be "evaluated").
       This ILI is used when multiple references of an ILM occur in the same
       ILM block.
       This ili is seen by the code generator but never appears in the
       linear ili.
       .AT arth null ir
       .CG notCG

       .IL APURE arlnk
       Call a pure function with no arguments and returns an AR value.
       Will always have an ALT which is the actual call.
       arlnk is an ACON ili of the function being called.
       .AT arth null ar cse
       .CG notCG

       .IL APUREA arlnk arlnk
       Call a pure function with one AR argument and returns an AR value.
       Will always have an ALT which is the actual call.
       arlnk is an ACON ili of the function being called.
       .AT arth null ar cse
       .CG notCG

       .IL APUREI arlnk irlnk
       Call a pure function with one IR argument and returns an AR value.
       Will always have an ALT which is the actual call.
       arlnk is an ACON ili of the function being called.
       .AT arth null ar cse
       .CG notCG

       .IL IPURE arlnk
       Call a pure function with no arguments and returns an IR value.
       Will always have an ALT which is the actual call.
       arlnk is an ACON ili of the function being called.
       .AT arth null ir cse
       .CG notCG

       .IL IPUREA arlnk arlnk
       Call a pure function with one AR argument and returns an IR value.
       Will always have an ALT which is the actual call.
       arlnk is an ACON ili of the function being called.
       .AT arth null ir cse
       .CG notCG

       .IL IPUREI arlnk irlnk
       Call a pure function with one IR argument and returns an IR value.
       Will always have an ALT which is the actual call.
       arlnk is an ACON ili of the function being called.
       .AT arth null ir cse
       .CG notCG

       .IL REP
       Repeat prefix opcode for string operations (such as the following SMOVE).
       Emitted immediately before an SMOVE operation.
       .AT other null trm dom
       .CG CGonly "rep"

       .IL GSMOVE arlnk arlnk nme nme stc
       General structure copy.
       A structure store (SMOVE ILM) is expanded into the GSMOVE ILI; a phase, such as
       the ACC CG, needs to have the structure assignment presented as a first-class
       ILI operation.
       After the last phase requiring GSMOVE, GSMOVE will then be expanded into
       lower level ILI which will be dependent on target, alignment, small vs large,
       etc.
         \'op1' is the source address.
         \'op2' is the destination address.
         \'nme1' is the names table entry for source struct.
         \'nme2' is the names table entry for the destination struct.
         \'stc' is the dtype of the struct.
       .AT other null trm dom
       .CG notCG

       .IL SMOVE arlnk arlnk arlnk nme
       Structure copy.
         \'op1' is the source address.
         \'op2' is the destination address.
         \'op3' is number of 4-byte units to copy.
         \'nme' is names table entry for destination struct.
       .AT other null trm dom
       .CG terminal "movs"

       .IL SMOVEJ arlnk arlnk nme nme stc
       Simple structure copy.  (MOVS is x86 parlance.)
       This is used to replace the SMOVEI/SMOVES pair, which was used when
       the ILI operand count was only 4.
       \'op1' is the source address
       \'op2' is the destination address
       \'nme1' is the names table entry for source struct.
       \'nme2' is the names table entry for the destination struct.
       \'op5' is actual number of bytes to copy.
       This gets turned into SMOVE and load/store operations by rm_smove
       .AT other null trm dom
       .CG notCG

       .IL XMOVE arlnk arlnk nme
       Structure copy.
         \'op1' is the source address.
         \'op2' is the destination address.
         \'nme' is names table entry for destination struct.
       .AT other null trm dom
       .CG terminal "movapd" sse_avx

       .IL ST irlnk arlnk nme stc
       Store integer value.
       In ILI, the value to be stored must fit without implicit truncation, i.e. immediately
       reloading using LD with the same size modifier must reproduce the value that was stored.
       In LILI or AILI, ST may perform implicit truncation.
       \'op1' is a pointer to an ili representing the value being stored.
       .br
       \'op2' is a pointer to the address expression of the variable being defined.
       .br
       \'nme' is a pointer to a names table entry of the variable being defined.
       .br
       \'stc' is the size modifier of the memory operation as described for
       the LD ili above.
       .AT store null trm
       .CG terminal "mov" move

       .IL STSP splnk arlnk nme stc
       Store single precision quantity.  'stc' is not used.
       .AT store null trm
       .CG terminal "movss" move

       .IL STDP dplnk arlnk nme stc
       Store double precision quantity.  'stc' is not used.
       .AT store null trm
       .CG terminal "movsd" move

       .IL STSCMPLX cslnk arlnk nme stc
       Store single precision complex quantity.  'stc' is not used.
       .AT store null trm
       .CG terminal "movsd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL STDCMPLX cdlnk arlnk nme stc
       Store double precision complex quantity.  'stc' is not used.
       .AT store null trm
       .CG terminal "movups" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL STQ dplnk arlnk nme stc
       Store m128 quantity.  'stc' is not used.
       .AT store null trm
       .CG terminal "movapd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL STQU dplnk arlnk nme stc
       Store unaligned m128 quantity.  'stc' is not used.
       .AT store null trm
       .CG terminal "movupd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL ST256 dplnk arlnk nme stc
       Store m256 quantity.  'stc' is not used.
       .AT store null trm
       .CG terminal "movapd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL ST256U dplnk arlnk nme stc
       Store unaligned m256 quantity.  'stc' is not used.
       .AT store null trm
       .CG terminal "movupd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL STA arlnk arlnk nme
       Store address quantity inside of op1 into op2.
       Replaced by ST opcode in cgoptim1.
       .AT store null trm
       .CG terminal notAILI

       .IL STRG1 arlnk stc
       Store address quantity inside of op1 argument register described by stc.
       Used in g++ style
       thunks when adjusting the \*this\* pointer, (the first argument) just
       before jumping through to the function Replaced by ST opcode in cgoptim1.
       .AT store null trm
       .CG terminal notAILI

       .IL STKR krlnk arlnk nme stc
       Store 64 bit integer value (in register pair).  'stc' is not used.
       .AT store null trm
       .CG terminal notAILI

       .IL VZST arlnk
       Special ili created by the vectorizer indicating that the variable
       whose address is op1 is stored; necessary in cases where
       the vectorizer replaces assignments with calls.  The optimizer will process
       the ili to create store information and then delete the ili.  Code generator
       will not see this ili.
       .AT other null trm
       .CG notCG

       .IL JSR sym lnk
       \'sym' is external function or subroutine being called (standard linkage).
       \'op2' points to a list (terminated by NULL) of ARG ili for the
       arguments.
       .AT proc null lnk dom
       .CG terminal "call" asm_special ccmod

       .IL JSRA arlnk lnk stc stc
       JSR to routine whose address is pointed to by op1.
       op2 points to the list of ARG ILIs which represents the arguments.
       stc1 attribute flag (stdcall in x86)
       stc2 dtype
       .AT proc null lnk dom
       .CG terminal notAILI ccmod

       .IL QJSR sym lnk
       Quick (intrinsic) call.
       \'sym' is the external procedure being called.
       \'op2' locates the list of arguments (define arg ILI - DAAR, DADR, DADP).
       .AT proc null lnk dom
       .CG terminal notAILI ccmod

       .IL GJSR sym lnk sym
       Same as JSR, but the argument list is expressed using the general argument
       ILI, i.e., before applying the ABI.
       \'sym2' is the label to jump to if an exception is thrown,
       0 if the call cannot throw,
       or -1 if there is no cleanup.
       .AT proc null lnk dom
       .CG terminal notCG

       .IL GJSRA arlnk lnk stc stc sym
       Same as JSRA, but the argument list is expressed using the general argument
       ILI, i.e., before applying the ABI.
       .AT proc null lnk dom
       .CG terminal notCG

       .IL NULL stc
       Used to mark the end of an argument list for a JSR, QJSR or JSRA ili.
       .AT other null lnk
       .CG notAILI

       .IL GARG lnk lnk stc nme
       A general argument link, used before applying the ABI
       .sp
       \'lnk' (first) points to the value of the argument.
       \'lnk' (second) points to the next ARG ILI.
       First \'stc' is the dtype.
       Second \'stc' is an NME value, if set, for address arguments.
       .AT define null lnk
       .CG

       .IL GARGRET lnk lnk stc nme
       A general argument link representing the return value of the function
       .sp
       \'lnk' (first) points to the value of the argument.
       \'lnk' (second) points to the next ARG ILI.
       \'stc' is the dtype
       \'nme' is the nme
       .AT define null lnk
       .CG notCG

       .IL VA_ARG arlnk stc
       va_arg(va_list x, typeof_arg) computes the address of the argument
       'arlnk' address of the va_list
       'stc' the dtype of the argument being reference
       .AT arth null ar
       .CG notCG

       .IL ARGIR irlnk lnk
       Defines an integer memory argument.
       \'irlnk' points to the register value of the argument.
       \'lnk' points to the next ARG ILI.
       .AT define null lnk
       .CG memarg "mov" 'l'

       .IL ARGSP splnk lnk
       Defines a single-precision memory argument.
       \'splnk' points to the register value of the argument.
       \'lnk' points to the next ARG ILI.
       .AT define null lnk
       .CG memarg "movss"

       .IL ARGDP dplnk lnk
       Defines a double precision memory argument.
       \'dplnk' points to the register value of the argument.
       \'lnk' points to the next ARG ILI.
       .AT define null lnk
       .CG memarg "movsd"

       .IL ARGAR arlnk lnk stc
       A memory argument of type pointer or struct/union.
       .sp
       \'arlnk' points to the value of the argument.
       .br
       \'lnk' points to the next ARG ILI.
       .br
       \'stc' is the dtype if this is a struct arg, else it is 0.
       If 'stc' == 1, then this argument is a pointer to the return area for a
       C function returning struct, and requires special treatment.
       .AT define null lnk
       .CG memarg "mov" 'l'

       .IL ARGKR krlnk lnk
       Defines a 64 bit integer memory argument.
       \'krlnk' points to the value of the argument.
       \'lnk' points to the next ARG ILI.
       .AT define null lnk
       .CG memarg notAILI

       .IL DAIR irlnk ir lnk
       Define integer argument in general purpose register for a JSR.
       .AT define null lnk
       .CG "mov" 'l' move

       .IL DASP splnk sp lnk
       Define a single precision argument in xmm register for a JSR.
       .AT define null lnk
       .CG "movss" move

       .IL DADP dplnk dp lnk
       Define a double precision argument in xmm register for a JSR.
       .AT define null lnk
       .CG "movsd" move

       .IL DACS cslnk cs lnk
       Define a C struct argument of two floats, passed in the indicated xmm register.
       .AT define null lnk
       .CG "movsd" move sse_avx
       .SI ld double fadd fmul fst lat(4)
       .SI st double fst lat(4)
       .SI double fadd fmul lat(2)

       .IL DACD cdlnk cd lnk
       Define a C struct argument of two double, passed in the indicated xmm register.
       .AT define null lnk
       .CG "movupd" move sse_avx
       .SI ld double fadd fmul fst lat(4)
       .SI st double fst lat(4)
       .SI double fadd fmul lat(2)

       .IL PSARG xmm stc lnk
       Move symbolic register 'xmm' into actual register 'stc' (typically
       XR_XMM0 or XR_XMM1) in preparation for call to vector intrinsic function.
       .AT define null lnk
       .CG "movaps" move sse_avx
       .SI ld double lat(4)
       .SI st double lat(3)
       .SI double lat(2)

       .IL PDARG xmm stc lnk
       Move symbolic register 'xmm' into actual register 'stc' (typically
       XR_XMM0 or XR_XMM1) in preparation for call to vector intrinsic function.
       .AT define null lnk
       .CG "movapd" move ssedp sse_avx
       .SI ld double fadd fmul fst lat(2)
       .SI st double fst lat(3)
       .SI double fadd fmul lat(2)

       .IL KISHFT krlnk krlnk
       Shift op1 by op2.  Left if op2 is > 0; else right (no sign extension).
       This ili only shows up for Fortran, specifically for the KISHFT intrinsic.
       If 2nd operand is compile time constant, this ili will have been
       replaced by either a left or right shift ili by the Expander.
       Otherwise, it is implemented as a call to a run-time function.
       .AT arth null kr cse
       .CG notCG

       .IL DAAR arlnk ar lnk
       Define argument in address register for a JSR.
       Lnk1 points to the expression to be moved into the specified (ar2)
       address register. Lnk3 locates the next argument for the JSR.
       .AT define null lnk
       .CG notCG replaceby DAIR

       .IL DAKR krlnk kr lnk
       Define argument in register pair for a JSR.
       .AT define null lnk
       .CG notCG

       .IL DFRIR lnk ir
       Define function result in a integer register.
       .AT define null ir cse
       .CG terminal asm_nop 'l'

       .IL DFRSP lnk sp
       Define single precision function result returned in xmm register 'sp'.
       .AT define null sp cse
       .CG terminal asm_nop

       .IL DFRDP lnk dp
       Define double precision function result returned in xmm register 'dp'.
       .AT define null dp cse
       .CG terminal asm_nop

       .IL DFRCS lnk cs
       Define single precision complex function result in an xmm register.
       .AT define null cs cse
       .CG terminal asm_nop

       .IL DFRCD lnk cd
       Define double precision complex function result in an xmm register.
       .AT define null cd cse
       .CG terminal asm_nop

       .IL DFRSPX87 lnk
       Define single precision function result (on floating-point stack).
       .AT define null sp cse
       .CG terminal "fstps"

       .IL DFRDPX87 lnk
       Define double precision function result (on floating-point stack).
       .AT define null dp cse
       .CG terminal "fstpl"

       .IL DFR128 lnk dp
       Define 128-bit function result in an xmm register.
       .AT define null dp cse
       .CG terminal asm_nop

       .IL DFR256 lnk dp
       Define 256-bit function result in an ymm register.
       .AT define null dp cse
       .CG terminal asm_nop

       .IL DFRAR lnk ar
       Define function result in an address register.
       \'op1' points to one of the JSR ILI.
       .AT define null ar cse
       .CG notCG replaceby DFRIR

       .IL DFRKR lnk kr
       Define integer64 function result in a register pair.
       .AT define null kr cse
       .CG terminal notAILI 'q'

       .IL IRDF ir
       Define one of the general purpose registers.
       These ILI (IRDF, DPDF, ARDF)  used for global
       register allocation, and for the pre-defined regs.
       .AT define null ir cse
       .CG terminal asm_nop 'l'

       .IL SPDF sp
       Define single precision register (xmm register).
       .AT define null sp cse
       .CG terminal asm_nop

       .IL DPDF dp
       Define double precision register (xmm register).
       .AT define null dp cse
       .CG terminal asm_nop

       .IL ARDF ar
       Define address register. (ar is actual register number).
       .AT define null ar cse
       .CG notCG replaceby IRDF

       .IL KRDF kr
       Define integer64 register.
       .AT define null kr
       .CG notCG

       .IL MVIR irlnk ir
       Move integer value into specific integer register, ir.
       .AT move null trm
       .CG terminal notAILI 'l'

       .IL MVSP splnk sp
       Indicates a single-precision function return value, which is to be placed
       on the x87 floating point stack.  The 2nd argument, 'sp', is ignored.
       .AT move null trm
       .CG terminal "flds"

       .IL MVDP dplnk dp
       Indicates a double-precision function return value, which is to be placed
       on the x87 floating point stack.  The 2nd argument, 'dp', is ignored.
       .AT move null trm
       .CG terminal "fldd"

       .IL SPSP2SCMPLX splnk splnk
       Form a single complex value out of two single precision real values.
       .AT other null cs cse
       .CG sse_avx asm_special

       .IL SPSP2SCMPLXI0 splnk
       Form a single complex value out of two single precision real values, imaginary is 0.
       .AT other null cs cse
       .CG sse_avx asm_special

       .IL DPDP2DCMPLX dplnk dplnk
       Form a double complex value out of two double precision real values.
       .AT other null cd cse
       .CG sse_avx asm_special

       .IL DPDP2DCMPLXI0 dplnk
       Form a double complex value out of two double precision real values, imaginary is 0.
       .AT other null cd cse
       .CG sse_avx asm_special

       .IL SCMPLX2IMAG cslnk
       Return single precision imaginary part of a single complex value.
       .AT other null sp cse
       .CG sse_avx asm_special

       .IL DCMPLX2IMAG cdlnk
       Return double precision imaginary part of a double complex value.
       .AT other null dp cse
       .CG sse_avx asm_special

       .IL SCMPLX2REAL cslnk
       Return single precision real part of a single complex value.
       .AT other null sp cse
       .CG sse_avx asm_special

       .IL DCMPLX2REAL cdlnk
       Return double precision real part of a double complex value.
       .AT other null dp cse
       .CG sse_avx asm_special

       .IL MVQ dplnk dp
       This ili represents a m128 function return value.
       For X86_64, the value is moved into the specified xmm register.
       .AT move null trm
       .CG terminal "movapd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL MV256 dplnk dp
       This ili represents a m256 function return value.
       For X86_64, the value is moved into the specified ymm register.
       .AT move null trm
       .CG terminal "movapd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL MOVSP
       Move a single-precision xmm register value.
       .AT move null sp
       .CG CGonly "movss" move

       .IL MOVDP
       Move a double-precision xmm register value.
       .AT move null dp
       .CG CGonly "movsd" move

       .IL MOVCS
       Move a single-precision complex xmm register value.
       .AT move null cs
       .CG CGonly "movsd" move

       .IL MOVCD
       Move a double-precision complex xmm register value.
       .AT move null cd
       .CG CGonly "movupd" move

       .IL MVSPX87 splnk
       Indicates a single-precision function return value, which is to be placed
       on the x87 floating point stack.
       .AT move null trm
       .CG terminal "flds"

       .IL MVDPX87 dplnk
       Indicates a double-precision function return value, which is to be placed
       on the x87 floating point stack.
       .AT move null trm
       .CG terminal "fldl"

       .IL MOVQP
       Move a __m128 xmm register value.
       .AT move null dp
       .CG CGonly "movapd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL MOV256
       Move a __m256 xmm register value.
       .AT move null dp
       .CG CGonly "movapd" move sse_avx
       .SI ld double fadd fmul fst lat(3)
       .SI st direct fst lat(2)
       .SI direct fadd fmul lat(2)

       .IL MVAR arlnk ar
       Move address value into specific address register, ar.
       .AT move null trm
       .CG terminal notCG replaceby MVIR

       .IL MVKR krlnk kr
       Move integer64 value into specific integer register pair, kr.
       .AT move null trm
       .CG terminal notAILI

       .IL FREEIR irlnk
       Ensures that the result reg is freed.
       The FREExx ili are eliminated by the linearizer phase of the code generator.
       .AT other null trm
       .CG terminal notAILI

       .IL FREESP splnk
       .AT other null trm
       .CG terminal notAILI

       .IL FREEDP dplnk
       .AT other null trm
       .CG terminal notAILI

       .IL FREECS cslnk
       .AT other null trm
       .CG terminal notAILI

       .IL FREECD cdlnk
       .AT other null trm
       .CG terminal notAILI

       .IL FREESPX87 splnk
       If necessary, pop X87 stack after a function call which returns a
       floating-point value which is not used.
       .AT other null trm
       .CG terminal "fstp\t%st(0)"

       .IL FREEDPX87 dplnk
       .AT other null trm
       .CG terminal "fstp\t%st(0)"

       .IL FREEAR arlnk
       .AT other null trm
       .CG terminal notCG replaceby FREEIR

       .IL FREEKR krlnk
       .AT other null trm
       .CG terminal notAILI

       .IL FREE lnk stc
       .AT other null trm
       .CG terminal notAILI

       .IL ENTRY sym
       Main function entry or fortran ENTRY.
       .AT other null trm dom
       .CG terminal asm_nop

       .IL EXIT sym
       Exit the procedure.
       .AT other null trm dom
       .CG terminal asm_special

       .IL ARGSAVE sym
       For varargs/stdargs functions, this ili appears immediately after ENTRY
       ili.  Not used by X86_32 compiler
       .AT other null trm dom
       .CG notCG

       .IL NOP
       Null operation - used when a linear ili or aili is deleted.
       .AT other null trm
       .CG asm_nop

       .IL ASM sym
       Implements C inline assembly code, asm(), feature. Also used as
       a convenience by the code generator.  'sym' is a symbol table
       pointer to a string constant.
       .AT other null trm dom
       .CG terminal asm_special ccmod

       .IL GASM sym lnk lnk lnk
       Compatible ASM language representation to support asm().
       sym - the asm string
       lnk1 - linked list of generic GASMLNKOs of output expressions
       lnk2 - linked list of specific GASMLNKI/SP/DP/As of input expressions
       lnk3 - linked list of generic GASMLNKCs of clobber strings
       NOTE: For now we add ccmod. In the future we may only want to indicate ccmod
       if the user specifies "cc" in the clobber list.
       .AT other null trm dom
       .CG terminal asm_special ccmod

       .IL GASMCNM sym sym
       Used to represent a symbolic name for a gasm constraint
       sym - identifier of constraint name. Stored as an int since we only care
             about the name, not its type.
       sym - constraint number
       .AT other null trm
       .CG terminal asm_nop

       .IL GASMLNKG sym nme lnk lnk
       generic gasmlnk;
       sym - descriptor string
       nme - nme being stored
       lnk1 - input or output expression
       lnk2 - next GASMLNKG
       .AT other null lnk
       .CG asm_nop

       .IL GASMLNKTYP stc lnk
       generic gasmlnk - stores type
       stc - base type of expression
       lnk1 - input or output expression
       .AT other null lnk
       .CG asm_nop

       .IL GASMLNKC sym lnk
       sym - descriptor string
       lnk - next GASMLNKC
       .AT other null lnk
       .CG asm_nop

       .IL GASMLNKO sym nme lnk stc
       sym - descriptor string
       nme - nme being stored
       lnk - next GASMLNKO
       stc - data type of expression
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKI sym nme irlnk lnk
       sym - descriptor string
       nme - nme being stored
       irlnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKB sym nme irlnk lnk
       Same as GASMLNKI, but represents byte reg
       sym - descriptor string
       nme - nme being stored
       irlnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKH sym nme irlnk lnk
       Same as GASMLNKI, but represents Half-word reg
       sym - descriptor string
       nme - nme being stored
       irlnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKKR sym nme irlnk lnk
       Same as GASMLNKI, but represents quad word reg (not currently used on 32-bit x86)
       sym - descriptor string
       nme - nme being stored
       irlnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKSP sym nme splnk lnk
       sym - descriptor string
       nme - nme being stored
       splnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKDP sym nme dplnk lnk
       sym - descriptor string
       nme - nme being stored
       dplnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKQP sym nme dplnk lnk
       sym - descriptor string
       nme - nme being stored
       dplnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKA sym nme arlnk lnk
       sym - descriptor string
       nme - nme being stored
       arlnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLNKS sym nme arlnk lnk
       the operand is a struct
       sym - descriptor string
       nme - nme being stored
       arlnk - the input expression
       lnk - next specific GASMLNK
       .AT other null lnk
       .CG "" asm_nop

       .IL GASMLDI stc stc nme
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null ir
       .CG asm_nop

       .IL GASMLDH stc stc nme
       half word register
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null ir
       .CG asm_nop

       .IL GASMLDB stc stc nme
       byte register
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null ir
       .CG asm_nop

       .IL GASMLDKR stc stc nme
       quad register
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null ir
       .CG asm_nop

       .IL GASMLDSP stc stc nme
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null sp
       .CG asm_nop

       .IL GASMLDDP stc stc nme
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null dp
       .CG asm_nop

       .IL GASMLDQP stc stc nme
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null dp
       .CG asm_nop

       .IL GASMLD256 stc stc nme
       __m256
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null dp
       .CG asm_nop

       .IL GASMLDA stc stc nme
       stc - output argument number, 0..n
       stc - optional field filled in by CG, this is the constraint used.
       nme - nme of object we're loading
       .AT other null ar
       .CG asm_nop

       .IL FPSAVE arlnk
       Store the frame pointer in the location whose address is specified
       by op1.
       .AT other null trm dom
       .CG terminal notAILI

       .IL VFENTER arlnk
       Enter a "function" which will compute the value of an expression
       used as a variable format field. op1 locates a temporary area
       used to set up the environment of the expression:
        op1+0 -- contains the fp to use for the expression
        op1+4 -- where to save the current fp
       The code for VFENTER performs the following:
       \1.  save current fp in addr(op1)+4
       \2.  load fp from addr(op1)+0
       .AT other null trm dom
       .CG terminal asm_special ccmod

       .IL VFEXIT arlnk irlnk
       Exit the variable format field function.  lnk1 locates the temporary
       area (see VFENTER).  lnk2 is the function return value. The code for
       VFEXIT performs the following:
       \1.  value of lnk2 --> integer function return register
       \2.  restore fp from addr(lnk1)+4
       \3.  return.
       .AT other null trm dom
       .CG terminal asm_special ccmod

       .IL PREFETCHNTA arlnk stc nme
       Prefetch cache line.  Non-Temporal Access - prefetch in such a way to
       minimize cache pollution.  Second operand, 'stc' is not used.
       .AT other null trm ssenme
       .CG terminal "prefetchnta"

       .IL PREFETCHT0 arlnk stc nme
       Prefetch cache line into all cache levels.
       .AT other null trm ssenme
       .CG terminal "prefetcht0"

       .IL PREFETCHW arlnk stc nme
       Prefetch cache line into L1 data cache.  Used in anticipation to subsequent
       store into the cache line.
       .AT other null trm ssenme
       .CG terminal "prefetchw"

       .IL PREFETCH arlnk stc nme
       Prefetch cache line into L1 data cache.
       .AT other null trm ssenme
       .CG terminal "prefetch"

       .IL LABEL sym
       This ILI represents a label 'sym' that is within a basic block.
       .AT other null trm dom
       .CG terminal asm_special

       .IL PSLD arlnk xmm nme
       Load 16 bytes from aligned memory into xmm register denoted by xmm.
       .AT pload null trm ssenme
       .CG terminal "movaps" move sse_avx

       .IL PDLD arlnk xmm nme
       Load 16 bytes from aligned memory into xmm register denoted by xmm.
       .AT pload null trm ssenme
       .CG terminal "movapd" move ssedp sse_avx

       .IL PILD arlnk xmm nme
       Load 16 bytes, 4 or 8 byte integer, from aligned memory into xmm register
       denoted by xmm.
       .AT pload null trm ssenme
       .CG terminal "movdqa" move ssedp sse_avx

       .IL PSLDU arlnk xmm nme
       Load 16 bytes from unaligned memory into xmm register denoted by xmm.
       .AT pload null trm ssenme
       .CG terminal "movups" move sse_avx

       .IL PDLDU arlnk xmm nme
       Load 16 bytes from unaligned memory into xmm register denoted by xmm.
       .AT pload null trm ssenme
       .CG terminal "movupd" move ssedp sse_avx

       .IL PILDU arlnk xmm nme
       Load 16 bytes, 4 or 8 byte integer, from unaligned memory into xmm register
       denoted by xmm.
       .AT pload null trm ssenme
       .CG terminal "movdqu" move ssedp sse_avx

       .IL PSLD_SCALAR arlnk xmm nme
       Move 4-byte scalar value whose address is indicated by arlnk,
       into least significant word of the 16-byte xmm register indicated by 'xmm'.
       .AT other null trm ssenme
       .CG terminal "movss"

       .IL PDLD_LOWH arlnk xmm nme
       Load 8 bytes from memory into low half of xmm register denoted by xmm.
       .AT other null trm ssenme
       .CG terminal "movlpd" ssedp

       .IL PDLD_HIGHH arlnk xmm nme
       Load 8 bytes from memory into high half of xmm register denoted by xmm.
       .AT other null trm ssenme
       .CG terminal "movhpd" ssedp

       .IL PI1INSERT arlnk xmm nme stc
       SSE4.1 and AVX instruction to load an integer\*1 value from 'arlnk' and
       insert it into 'xmm' at the byte offset given by 'stc'.
       .AT other null trm ssenme
       .CG terminal "pinsrb" sse_avx asm_special

       .IL PI2INSERT arlnk xmm nme stc
       SSE2 and AVX instruction to load an integer\*2 value from 'arlnk' and
       insert it into 'xmm' at the word offset given by 'stc' (where a 'word'
       is 2 bytes).
       .AT other null trm ssenme
       .CG terminal "pinsrw" sse_avx asm_special

       .IL PI4INSERT arlnk xmm nme stc
       SSE4.1 and AVX instruction to load an integer\*4 value from 'arlnk' and
       insert it into 'xmm' at the dword offset given by 'stc' (where a
       'dword' is 4 bytes).
       .AT other null trm ssenme
       .CG terminal "pinsrd" sse_avx asm_special

       .IL PI8INSERT arlnk xmm nme stc
       SSE4.1 and AVX instruction to load an integer\*8 value from 'arlnk' and
       insert it into 'xmm' at the qword offset given by 'stc' (where a
       'qword' is 8 bytes).  This instruction cannot be used on x86-32.
       .AT other null trm ssenme
       .CG notCG

       .IL PSLD_LOWH arlnk xmm nme
       Load 2 single precision values to low half of xmm register.
       This opcode and the next are used in combination, in place of "movups"
       due to a Hammer performance penalty for using "movups".
       .AT other null trm ssenme
       .CG terminal "movlps"

       .IL PSLD_HIGHH arlnk xmm nme
       Load 2 single precision values to high half of xmm register.
       .AT other null trm ssenme
       .CG terminal "movhps"

       .IL PSST arlnk xmm nme
       Store 16 bytes from xmm register denoted by xmm into aligned memory.
       .AT pstore null trm ssenme
       .CG terminal "movaps" move ssest sse_avx

       .IL PDST arlnk xmm nme
       Store 16 bytes from xmm register denoted by xmm into aligned memory.
       .AT pstore null trm ssenme
       .CG terminal "movapd" move ssedp ssest sse_avx

       .IL PIST arlnk xmm nme
       Store 16 bytes, 4 or 8 byte integer, from xmm register denoted by xmm
       into aligned memory.
       .AT pstore null trm ssenme
       .CG terminal "movdqa" move ssedp ssest sse_avx

       .IL PSSTU arlnk xmm nme
       Store 16 bytes from xmm register denoted by xmm into unaligned memory.
       .AT pstore null trm ssenme
       .CG terminal "movups" move ssest sse_avx

       .IL PDSTU arlnk xmm nme
       Store 16 bytes from xmm register denoted by xmm into unaligned memory.
       .AT pstore null trm ssenme
       .CG terminal "movupd" move ssedp ssest sse_avx

       .IL PISTU arlnk xmm nme
       Store 16 bytes, 4 or 8 byte integer, from xmm register denoted by xmm
       into unaligned memory.
       .AT pstore null trm ssenme
       .CG terminal "movdqu" move ssedp ssest sse_avx

       .IL PSSTS arlnk xmm nme
       Streaming store.
       Store 16 bytes from xmm register denoted by xmm into aligned memory
       bypassing cache.
       .AT pstore null trm ssenme
       .CG terminal "movntps" move ssest sse_avx

       .IL PSSTS_SCALAR arlnk xmm nme
       Scalar streaming store single precision quantity.
       .AT other null trm ssenme
       .CG terminal "movntss" move ssest

       .IL SSTS_SCALAR splnk arlnk nme stc
       Scalar streaming store single precision quantity.
       .AT store null trm
       .CG terminal "movntss" move

       .IL PDSTS arlnk xmm nme
       Streaming store.
       Store 16 bytes from xmm register denoted by xmm into aligned memory
       bypassing cache.
       .AT pstore null trm ssenme
       .CG terminal "movntpd" move ssedp ssest sse_avx

       .IL PDSTS_SCALAR arlnk xmm nme
       Scalar streaming store double precision quantity.
       .AT other null trm ssenme
       .CG terminal "movntsd" move ssedp ssest

       .IL DSTS_SCALAR dplnk arlnk nme
       Scalar streaming store double precision quantity.
       .AT store null trm
       .CG terminal "movntsd" move

       .IL PISTS arlnk xmm nme
       Streaming store.  Store 16 bytes, 4 or byte integer, from xmm register
       denoted by xmm into aligned memory, bypassing cache.
       .AT pstore null trm ssenme
       .CG terminal "movntdq" move ssedp ssest sse_avx

       .IL PSST_SCALAR arlnk xmm nme
       Store value from xmm register into 4-byte variable.
       .AT other null trm ssenme
       .CG terminal "movss" move ssest

       .IL PDST_LOWH arlnk xmm nme
       Store low half of xmm register into 8-byte memory location.
       .AT other null trm ssenme
       .CG terminal "movsd" move ssedp ssest

       .IL PDST_HIGHH arlnk xmm nme
       Store high half of xmm register into 8-byte memory location.
       .AT other null trm ssenme
       .CG terminal "movhpd" ssedp ssest

       .IL PSST_LOWH arlnk xmm nme
       Store 2 single precision values from low half of xmm register.
       This opcode and the next are used in combination, in place of "movups"
       due to a Hammer performance penalty for using "movups".
       .AT other null trm ssenme
       .CG terminal "movlps" ssest

       .IL PSST_HIGHH arlnk xmm nme
       Store 2 single precision values from high half of xmm register.
       .AT other null trm ssenme
       .CG terminal "movhps" ssest

       .IL SFENCE
       X86 sfence instruction used in conjunction with streaming stores.
       .AT other null trm dom
       .CG terminal "sfence"

       .IL PSMOVX xmm xmm
       Move low order 4 byte value of xmm1 into low order 4 bytes of xmm2, without
       disturbing the other 12 bytes of xmm2.
       .AT other null trm
       .CG terminal "movss"
       .SI ld double lat(4)
       .SI st double lat(3)
       .SI double lat(2)

       .IL PSMOV xmm xmm
       Move contents of one xmm register into a 2nd xmm register.
       .AT other null trm
       .CG terminal "movaps" move sse_avx

       .IL PDMOV xmm xmm
       Move contents of one xmm register into a 2nd xmm register.
       .AT other null trm
       .CG terminal "movapd" move ssedp sse_avx

       .IL PIMOV xmm xmm
       Move contents of xmm register containing 4 or 8-byte integers.
       .AT other null trm
       .CG terminal "movdqa" move sse_avx

       .IL PSDFR stc xmm
       Move 16-byte register 'stc' containing result of vector intrinsic function,
       into symbolic register 'xmm'.  'stc' is typically XR_XMM0.
       .AT other null trm
       .CG terminal "movaps" move sse_avx

       .IL PDDFR stc xmm
       Move 16-byte register 'stc' containing result of vector intrinsic function,
       into symbolic register 'xmm'.  'stc' is typically XR_XMM0.
       .AT other null trm
       .CG terminal "movapd" move ssedp sse_avx

       .IL PDMV_LOWH dplnk xmm
       Move d.p. value into low half of xmm register.
       This operation is used for the streaming store optimization.
       .AT other null trm
       .CG terminal "movlpd" move ssedp

       .IL PI8MV_LOW krlnk xmm
       Move 8-byte integer value into low half of xmm register.
       .AT other null trm
       .CG terminal notAILI

       .IL PDMV_HIGHH dplnk xmm
       Move d.p. value into high half of xmm register.
       This operation is used for the streaming store optimization.
       If input operand is a register, the "unpcklpd" instruction is used
       instead.
       .AT other null trm
       .CG terminal "movhpd" ssedp

       .IL PDMV_DUP dplnk xmm
       Move 1 double precision value into both high & low half of xmm register.
       .AT other null trm
       .CG terminal "movddup" ssedp sse_avx
       .SI double fmul lat(4)

       .IL PSMV_LOW splnk xmm
       Load value of single precision expression into register.
       .AT other null trm
       .CG terminal "movss" move

       .IL PI4MV_LOW irlnk xmm
       Move 4-byte integer into low half of xmm register.  Used to initialize an
       invariant variable in the preheader of a loop.
       .AT other null trm
       .CG terminal "movd"

       .IL MOVHLPS xmm xmm
       Move high half of sp values from one xmm register into a low half of 2nd
       xmm register.
       .AT other null trm
       .CG terminal "movhlps"

       .IL MOVLHPS xmm xmm
       Move low half of sp values from one xmm register into a high half of 2nd
       xmm register.
       .AT other null trm
       .CG terminal "movlhps"

       .IL UNPCKLPS xmm xmm
       .AT other null trm
       .CG terminal "unpcklps"

       .IL UNPCKHPS xmm xmm
       .AT other null trm
       .CG terminal "unpckhps"

       .IL UNPCKLPD xmm xmm
       Copy low halves of each operand into the destination operand.
       .AT other null trm
       .CG terminal "unpcklpd" ssedp

       .IL UNPCKHPD xmm xmm
       Copy high halves of each operand into the destination operand.
       .AT other null trm
       .CG terminal "unpckhpd" ssedp

       .IL UNPCKLDQ xmm xmm
       Take the 2 low doublewords (of 4 bytes each) of each operand and
       interleave them into the destination (i.e. second) operand.  Only used
       in AILIs on x86-32, where it is generated from an IL_PI8MV_LOW ILI.
       Not used on x86-64.
       .AT other null trm
       .CG CGonly "punpckldq" ssedp

       .IL UNPCKLQDQ xmm xmm
       Copy low halves of each operand into the destination operand.
       Input register contain 8-byte integers.
       .AT other null trm
       .CG terminal "punpcklqdq" ssedp

       .IL HADDPS xmm xmm
       Horizontal add packed single.
       .AT other null trm
       .CG terminal "haddps" sse_avx

       .IL HSUBPS xmm xmm
       Horizontal subtract packed single.
       .AT other null trm
       .CG terminal "hsubps" sse_avx

       .IL HADDPD xmm xmm
       Horizontal add packed double.
       .AT other null trm
       .CG terminal "haddpd" ssedp sse_avx

       .IL HSUBPD xmm xmm
       Horizontal subtract packed double.
       .AT other null trm
       .CG terminal "hsubpd" ssedp sse_avx

       .IL PSSHUF xmm xmm stc
       Shuffle contents of xmm registers.  Used to move value in
       least significant word into the 3 other words of a register:
       xmm1 and xmm2 denote the (same) xmm register, and stc3 is the
       immediate constant 0.
       .AT other null trm
       .CG terminal "shufps" asm_special

       .IL PDSHUF xmm xmm stc
       Shuffle contents of xmm registers.  Used to switch 2 d.p. values
       in register.
       .AT other null trm
       .CG terminal "shufpd" asm_special ssedp


       .IL PI4SHUF xmm xmm stc
       Shuffle contents of xmm register containing 4-byte integers.
       .AT other null trm
       .CG terminal "pshufd" asm_special

       .IL PTEST xmm xmm
       This sets the ZF flag if the bitwise AND of all the bits in the xmm
       register operands is 0, otherwise it clears the ZF flag, and it sets
       the CF flag if the bitwise ANDN of all the bits in the operands is 0,
       otherwise it clears the CF flag.  Due to the latter operation its
       operands are not commutative.  It clears the AF, OF, PF and SF flags.
       .AT other null ir
       .CG "ptest" ccmod sse_avx asm_special


       .IL PI4ADD arlnk xmm nme
       .AT other comm trm ssenme
       .CG terminal "paddd" sse_avx

       .IL PI4SUBR arlnk xmm nme
       Integer reverse-subtract.
       .AT other null trm ssenme
       .CG terminal "psubd" sse_avx

       .IL PI4AND arlnk xmm nme
       .AT other comm trm ssenme
       .CG terminal "pand" sse_avx

       .IL PI4ANDN arlnk xmm nme
       .AT other null trm ssenme
       .CG terminal "pandn" sse_avx

       .IL PI4OR arlnk xmm nme
       .AT other comm trm ssenme
       .CG terminal "por" sse_avx

       .IL PI4XOR arlnk xmm nme
       .AT other comm trm ssenme
       .CG terminal "pxor" sse_avx

       .IL PI4MAX arlnk xmm nme
       SSE4.1 packed signed dword integer maximum.
       .AT other comm trm ssenme
       .CG terminal "pmaxsd" sse_avx

       .IL PI4MIN arlnk xmm nme
       SSE4.1 packed signed dword integer minimum.
       .AT other comm trm ssenme
       .CG terminal "pminsd" sse_avx


       .IL PI8ADD arlnk xmm nme
       .AT other comm trm ssenme
       .CG terminal "paddq" sse_avx

       .IL PI8SUBR arlnk xmm nme
       Integer reverse-subtract.
       .AT other null trm ssenme
       .CG terminal "psubq" sse_avx

       .IL PI8AND arlnk xmm nme
       .AT other comm trm ssenme
       .CG terminal "pand" sse_avx

       .IL PI8ANDN arlnk xmm nme
       .AT other null trm ssenme
       .CG terminal "pandn" sse_avx

       .IL PI8OR arlnk xmm nme
       .AT other comm trm ssenme
       .CG terminal "por" sse_avx

       .IL PI8XOR arlnk xmm nme
       .AT other comm trm ssenme
       .CG terminal "pxor" sse_avx


       .IL PI4ADDX xmm xmm
       .AT other comm trm
       .CG terminal "paddd" sse_avx

       .IL PI4SUBRX xmm xmm
       Integer reverse-subtract.
       .AT other null trm
       .CG terminal "psubd" sse_avx

       .IL PI4ANDX xmm xmm
       .AT other comm trm
       .CG terminal "pand" sse_avx

       .IL PI4ANDNX xmm xmm
       .AT other null trm
       .CG terminal "pandn" sse_avx

       .IL PI4ORX xmm xmm
       .AT other comm trm
       .CG terminal "por" sse_avx

       .IL PI4XORX xmm xmm
       .AT other comm trm
       .CG terminal "pxor" sse_avx


       .IL PI8ADDX xmm xmm
       .AT other comm trm
       .CG terminal "paddq" sse_avx

       .IL PI8SUBRX xmm xmm
       Integer reverse-subtract.
       .AT other null trm
       .CG terminal "psubq" sse_avx

       .IL PI8ANDX xmm xmm
       .AT other comm trm
       .CG terminal "pand" sse_avx

       .IL PI8ANDNX xmm xmm
       .AT other null trm
       .CG terminal "pandn" sse_avx

       .IL PI8ORX xmm xmm
       .AT other comm trm
       .CG terminal "por" sse_avx

       .IL PI8XORX xmm xmm
       .AT other comm trm
       .CG terminal "pxor" sse_avx


       .IL PI4CMPX xmm xmm stc
       Vector dword integer compare; stc is the compare code;
       one of the instructions pcmpXXd is generated for this ili.
       .AT other null trm
       .CG terminal asm_special

       .IL PI8CMPX xmm xmm stc
       Vector qword integer compare; stc is the compare code;
       one of the instructions pcmpXXq is generated for this ili.
       .AT other null trm
       .CG terminal asm_special

       .IL PI4MAXX xmm xmm
       SSE4.1 packed signed dword integer maximum.
       .AT other comm trm
       .CG terminal "pmaxsd" sse_avx

       .IL PI4MINX xmm xmm
       SSE4.1 packed signed dword integer minimum.
       .AT other comm trm
       .CG terminal "pminsd" sse_avx

       .IL PUI4MAXX xmm xmm
       SSE4.1 packed unsigned dword integer maximum.
       .AT other comm trm
       .CG terminal "pmaxud"

       .IL PUI4MINX xmm xmm
       SSE4.1 packed unsigned dword integer minimum.
       .AT other comm trm
       .CG terminal "pminud"

       .IL PUI4MAX arlnk xmm nme
       SSE4.1 packed unsigned dword integer maximum.
       .AT other comm trm ssenme
       .CG terminal "pmaxud"

       .IL PUI4MIN arlnk xmm nme
       SSE4.1 packed unsigned dword integer minimum.
       .AT other comm trm ssenme
       .CG terminal "pminud"

       .IL PSADD arlnk xmm nme
       Perform 4 single-precision floating-point adds of the 4 values
       in the 16-byte aligned memory location denoted by arlnk, and
       the 4 values in the xmm register denoted by xmm.
       The results are placed in xmm register 'xmm'.
       .AT other comm trm ssenme
       .CG terminal "addps" sse_avx

       .IL PSSUBR arlnk xmm nme
       Reverse subtract: computes 'xmm' - 'arlnk', result placed in the
       xmm register denoted by 'xmm'.
       .AT other null trm ssenme
       .CG terminal "subps" sse_avx

       .IL PSMUL arlnk xmm nme
       Multiply contents of memory and 16-byte xmm register.
       .AT other comm trm ssenme
       .CG terminal "mulps" sse_avx

       .IL PSDIVR arlnk xmm nme
       Reverse divide: op2/op1 -> op2.
       .AT other null trm ssenme
       .CG terminal "divps" sse_avx

       .IL PSAND arlnk xmm nme
       Bitwise AND operation on s.p. values - used to implement absolute value.
       .AT other comm trm ssenme
       .CG terminal "andps" sse_avx

       .IL PSXOR arlnk xmm nme
       Bitwise XOR operation on s.p. values.
       .AT other comm trm ssenme
       .CG terminal "xorps" sse_avx

       .IL PSMAX arlnk xmm nme
       Single-precision packed maximum.
       .AT other comm trm ssenme
       .CG terminal "maxps" sse_avx

       .IL PSMIN arlnk xmm nme
       Single-precison packed minimum.
       .AT other comm trm ssenme
       .CG terminal "minps" sse_avx

       .IL PSSQRT arlnk xmm nme
       Compute square root of 4 s.p. values in memory and put result into
       xmm register denoted by xmm.
       .AT other null trm ssenme
       .CG terminal "sqrtps" sse_avx

       .IL RCPPS arlnk xmm nme
       Compute single-precision approximations to reciprocal.
       .AT other null trm ssenme
       .CG terminal "rcpps" sse_avx

       .IL RSQRTPS arlnk xmm nme
       Compute single-precision approximations to reciprocal square root.
       .AT other null trm ssenme
       .CG terminal "rsqrtps" sse_avx

       .IL CMPNEQPS arlnk xmm nme
       Used for single-precision sqrt approximation.
       .AT other null trm ssenme
       .CG terminal "cmpneqps" sse_avx

       .IL PSADDX xmm xmm
       Perform 4 single-precision floating point additions of the 4
       values in xmm register xmm1 and the 4 values in register xmm2.
       The results are placed in register xmm2.
       .AT other comm trm
       .CG terminal "addps" sse_avx

       .IL PSSUBRX xmm xmm
       Reverse-subtract contents of two 16-byte xmm registers.
       .AT other null trm
       .CG terminal "subps" sse_avx

       .IL PSMULX xmm xmm
       Multiply contents of two 16-byte xmm registers.
       .AT other comm trm
       .CG terminal "mulps" sse_avx

       .IL PSDIVRX xmm xmm
       Reverse-divide contents of two 16-byte xmm registers.
       .AT other null trm
       .CG terminal "divps" sse_avx

       .IL PSANDX xmm xmm
       Bitwise AND operation on s.p. values - used to implement absolute value.
       .AT other comm trm
       .CG terminal "andps" sse_avx

       .IL PSANDNX xmm xmm
       Bitwise ANDNOT operation on s.p. values.
       .AT other null trm
       .CG terminal "andnps" sse_avx

       .IL PSORX xmm xmm
       Bitwise OR operation on s.p. values.
       .AT other comm trm
       .CG terminal "orps" sse_avx

       .IL PSXORX xmm xmm
       Compute bitwise exclusive-OR of two xmm registers and place result
       in second register.
       .AT other comm trm
       .CG terminal "xorps" sse_avx

       .IL PSMAXX xmm xmm
       Single precision packed maximum.
       .AT other comm trm
       .CG terminal "maxps" sse_avx

       .IL PSMINX xmm xmm
       Single precision packed minimum.
       .AT other comm trm
       .CG terminal "minps" sse_avx

       .IL PSSQRTX xmm xmm
       Compute square root of 4 s.p. values in 1st xmm register and put result into
       2nd xmm register.
       .AT other null trm
       .CG terminal "sqrtps" sse_avx

       .IL RCPPSX xmm xmm
       Compute single-precision approximations to reciprocal.
       .AT other null trm
       .CG terminal "rcpps" sse_avx

       .IL RSQRTPSX xmm xmm
       Compute single-precision approximations to reciprocal square root.
       .AT other null trm
       .CG terminal "rsqrtps" sse_avx

       .IL CMPNEQPSX xmm xmm
       Used for single-precision square root approximation.
       .AT other null trm
       .CG terminal "cmpneqps" sse_avx

       .IL PSCMPX xmm xmm stc
       Vector compare of single precision values.  'stc' is comparison code.
       One of the instructions cmpXXps is generated for this ili.
       .AT other null trm
       .CG terminal asm_special

       .IL PDADD arlnk xmm nme
       Perform 2 double-precision floating-point adds of the 2 values
       in the 16-byte aligned memory location denoted by arlnk, and
       the 2 values in the xmm register denoted by xmm.
       The results are placed in xmm register 'xmm'.
       .AT other comm trm ssenme
       .CG terminal "addpd" ssedp sse_avx

       .IL PDSUBR arlnk xmm nme
       Reverse subtract: computes 'xmm' - 'arlnk', result placed in the
       xmm register denoted by 'xmm'.
       .AT other null trm ssenme
       .CG terminal "subpd" ssedp sse_avx

       .IL PDMUL arlnk xmm nme
       Multiply contents of memory and 16-byte xmm register.
       .AT other comm trm ssenme
       .CG terminal "mulpd" ssedp sse_avx

       .IL PDDIVR arlnk xmm nme
       Reverse divide: op2/op1 -> op2.
       .AT other null trm ssenme
       .CG terminal "divpd" ssedp sse_avx

       .IL PDAND arlnk xmm nme
       Bitwise AND operation on d.p. values - used to implement absolute value.
       .AT other comm trm ssenme
       .CG terminal "andpd" ssedp sse_avx

       .IL PDXOR arlnk xmm nme
       Bitwise XOR operation on d.p. values.
       .AT other comm trm ssenme
       .CG terminal "xorpd" ssedp sse_avx

       .IL PDMAX arlnk xmm nme
       Double precision packed maximum.
       .AT other comm trm ssenme
       .CG terminal "maxpd" ssedp sse_avx

       .IL PDMIN arlnk xmm nme
       Double precision packed minimum.
       .AT other comm trm ssenme
       .CG terminal "minpd" ssedp sse_avx

       .IL PDSQRT arlnk xmm nme
       Compute square root of 2 d.p. values in memory and put result into
       xmm register denoted by xmm.
       .AT other null trm ssenme
       .CG terminal "sqrtpd" ssedp sse_avx

       .IL PDADDX xmm xmm
       Perform 2 double-precision floating point additions of the 2
       values in xmm register xmm1 and the 2 values in register xmm2.
       The results are placed in register xmm2.
       .AT other comm trm
       .CG terminal "addpd" ssedp sse_avx

       .IL PDSUBRX xmm xmm
       Reverse-subtract contents of two 16-byte xmm registers.
       .AT other null trm
       .CG terminal "subpd" ssedp sse_avx

       .IL PSADDSUBX xmm xmm
       Perform single-precision floating point additions of the 2
       values in xmm register xmm1 and the 2 values in register xmm2.
       The results are placed in register xmm2.
       .AT other null trm
       .CG terminal "addsubps"  sse_avx
       .SI double fadd lat(5:7)

       .IL PDADDSUBX xmm xmm
       Perform double-precision floating point additions of the 2
       values in xmm register xmm1 and the 2 values in register xmm2.
       The results are placed in register xmm2.
       .AT other null trm
       .CG terminal "addsubpd" ssedp sse_avx
       .SI double fadd lat(5:7)

       .IL MOVSHDUPX xmm
       Move packed single precision and duplicate high.  Used to get imaginary part of single complex.
       Source can be memory.
       .AT other null trm
       .CG terminal "movshdup" ssedp sse_avx

       .IL MOVSLDUPX xmm
       Move packed single precision and duplicate low.  Can be used to get real part of single complex.
       Source can be memory.
       .AT other null trm
       .CG terminal "movsldup" ssedp sse_avx

       .IL PDMULX xmm xmm
       Multiply contents of two 16-byte xmm registers.
       .AT other comm trm
       .CG terminal "mulpd" ssedp sse_avx

       .IL PDDIVRX xmm xmm
       Reverse-divide contents of two 16-byte xmm registers.
       .AT other null trm
       .CG terminal "divpd" ssedp sse_avx

       .IL PDANDX xmm xmm
       Bitwise AND operation on d.p. values - used to implement absolute value.
       .AT other comm trm
       .CG terminal "andpd" ssedp sse_avx

       .IL PDANDNX xmm xmm
       Bitwise ANDNOT operation on d.p. values.
       .AT other null trm
       .CG terminal "andnpd" ssedp sse_avx

       .IL PDORX xmm xmm
       Bitwise OR operation on d.p. values.
       .AT other comm trm
       .CG terminal "orpd" ssedp sse_avx

       .IL PDXORX xmm xmm
       Compute bitwise exclusive-OR of two xmm registers and place result
       in second register.
       .AT other comm trm
       .CG terminal "xorpd" ssedp sse_avx

       .IL PDMAXX xmm xmm
       Double precision packed maximum.
       .AT other comm trm
       .CG terminal "maxpd" ssedp sse_avx

       .IL PDMINX xmm xmm
       Double precision packed minimum.
       .AT other comm trm
       .CG terminal "minpd" ssedp sse_avx

       .IL PDSQRTX xmm xmm
       Compute square root of 2 d.p. values in 1st xmm register and put result into
       2nd xmm register.
       .AT other null trm
       .CG terminal "sqrtpd" ssedp sse_avx

       .IL PDCMPX xmm xmm stc
       Vector compare of double precision values.  'stc' is comparison code.
       One of the instructions cmpXXpd is generated for this ili.
       .AT other null trm
       .CG terminal asm_special ssedp

       .IL PSLLSH irlnk xmm
       Shift packed 4-byte integers left.
       .AT other null trm
       .CG terminal "pslld"

       .IL PSRLSH irlnk xmm
       Shift packed 4-byte integers logical right (zero fill).
       .AT other null trm
       .CG terminal "psrld"

       .IL PSRASH irlnk xmm
       Shift packed 4-byte integers arithmetically right (sign extend).
       .AT other null trm
       .CG terminal "psrad"

       .IL PDLLSH irlnk xmm
       Shift packed 8-byte integers left.
       .AT other null trm
       .CG terminal "psllq" ssedp

       .IL PDRLSH irlnk xmm
       Shift packed 8-byte integers logical right (zero fill).
       .AT other null trm
       .CG terminal "psrlq" ssedp

       .IL PDRASH irlnk xmm
       Shift packed 8-byte integers arithmetically right (sign extend).
       NO SUCH INSTRUCTION.
       .AT other null trm
       .CG notCG terminal "psraq" ssedp

       .IL PBBLENDX xmm xmm xmm
       SSE4.1 Variable Blend Packed Bytes
       .AT other null trm
       .CG terminal "pblendvb" asm_special

       .IL PSBLENDX xmm xmm xmm
       SSE4.1 Variable Blend Packed Single Precision Floating-Point Values
       .AT other null trm
       .CG terminal "blendvps" asm_special

       .IL PDBLENDX xmm xmm xmm
       SSE4.1 Variable Blend Packed Double Precision Floating-Point Values
       .AT other null trm
       .CG terminal "blendvpd" asm_special ssedp

       .IL PBBLEND arlnk xmm nme xmm
       SSE4.1 Variable Blend Packed Bytes
       .AT other null trm ssenme
       .CG terminal "pblendvb" asm_special

       .IL PSBLEND arlnk xmm nme xmm
       SSE4.1 Variable Blend Packed Single Precision Floating-Point Values
       .AT other null trm ssenme
       .CG terminal "blendvps" asm_special

       .IL PDBLEND arlnk xmm nme xmm
       SSE4.1 Variable Blend Packed Double Precision Floating-Point Values
       .AT other null trm ssenme
       .CG terminal "blendvpd" asm_special ssedp


       .IL VFEXTRACT128X xmm xmm stc
       An AVX-only ILI.  Extract 128 bits of packed floating-point values
       from xmm1 (a ymm register) at an offset determined by stc (0 = bits
       0:127 of xmm1, 1 = bits 128:255 of xmm1), and store the result in xmm2
       (an xmm register).
       .AT other null trm
       .CG terminal "vextractf128" avx_only asm_special

       .IL VFINSERT128X xmm xmm xmm stc
       Insert 128-bits of packed floatingpoint values from xmm1 and
       the remaining values from xmm2(ymm register) into xmm3(ymm register)
       .AT other null trm
       .CG terminal "vinsertf128" avx_only asm_special



       .IL PDFMA arlnk xmm nme xmm
       A packed double-precision FMA3 or FMA4 instruction which computes:
           dest = <sign> (src1 \* src2) <addop> src3
       where:
           arlink = src2 or src3
           xmm1   = src1
           xmm2   = ((arlnk == src2) ? src3 : src2)
       .br
       Since ILIs have a maximum of 4 operands this ILI is always immediately
       preceded by an FMATYPE ILI which provides other information about the
       FMA instruction, namely (i) flags to specify the values of <sign>
       (+/-) and <addop> (+/-), and to indicate whether 'arlnk' corresponds
       to 'src2' or 'src3', and (ii) the 'dest' operand.
       .AT other null trm ssenme
       .CG terminal asm_special ssedp

       .IL PDFMAX xmm xmm xmm xmm
       A packed double-precision FMA3 or FMA4 instruction which computes:
       	dest = <sign> (src1 \* src2) <addop> src3
       where:
       	xmm1 = src1
       	xmm2 = src2
       	xmm3 = src3
       	xmm4 = dest
       .br
       Note, for FMA3 'dest' must be the same as one of the source operands.
       .br
       Since ILIs have a maximum of 4 operands this ILI is always immediately
       preceded by an FMATYPE ILI which specifies the values of <sign> (+/-)
       and <addop> (+/-).
       .AT other null trm
       .CG terminal asm_special ssedp

       .IL PSFMA arlnk xmm nme xmm
       This is the same as PDFMA except that it specifies a packed single
       precision FMA3 or FMA4 instruction.
       .AT other null trm ssenme
       .CG terminal asm_special

       .IL PSFMAX xmm xmm xmm xmm
       This is the same as PDFMAX except that it specifies a packed single
       precision FMA3 or FMA4 instruction.
       .AT other null trm
       .CG terminal asm_special

       .IL FMATYPE stc xmm
       This provides extra information about the immediately following PDFMA,
       PDFMAX, PSFMA or PSFMAX ILI.  Its operands are:
       .br
       stc = a set of flags which specify the values of <sign> (+/-) and
             <addop> (+/-), and for PDFMA and PSFMA, whether arlnk is src2 or
             src3.  The flags are defined by 'FMA\_...' macros in "ili.h".
       .br
       xmm = the 'dest' operand for PDFMA or PSFMA, or 0 for PDFMAX and PSFMAX.
             For FMA3 'dest' must be the same as one of the source operands,
             i.e. one of the xmm operands in the PDFMA or PSFMA ILI.
       .AT other null trm
       .CG terminal notAILI

       .IL CLTD
       Used with signed integer divide/mod instruction.
       .AT other null ir
       .CG CGonly "cltd" ccmod asm_special

       .IL CQTO
       Not used by X86_32 compiler
       .AT other null kr
       .CG notCG notAILI

       .IL CMOV
       Conditionally copy op2 into op1 based on condition codes.
       .AT load null ir
       .CG CGonly asm_special "cmov"

       .IL CMOVSP
       Single precision conditional move.  Expanded by the CG.
       .AT load null sp
       .CG CGonly asm_special "movss"

       .IL CMOVDP
       Double precision conditional move.  Expanded by the CG.
       .AT load null dp
       .CG CGonly asm_special "movsd"

       .IL CMOVSCMPLX
       Single precision complex conditional move.  Expanded by the CG.
       .AT load null cs
       .CG CGonly asm_special "movsd"

       .IL CMOVDCMPLX
       Double precision complex conditional move.  Expanded by the CG.
       .AT load null cd
       .CG CGonly asm_special "movupd"

       .IL CMOVLPD
       Same as CMOVDP, but used when "movlpd" is preferred.
       .AT load null dp
       .CG CGonly asm_special "movlpd"

       .IL CSETB
       Conditional set of a byte
       .AT store null ir
       .CG CGonly asm_special "set"
       .SI ld direct lat(4)
       .SI direct lat(1)

       .IL INC
       Increment integer register or memory operand.
       .AT arth null ir cse
       .CG CGonly ccarith "inc"

       .IL DEC
       Decrement integer register or memory operand.
       .AT arth null ir cse
       .CG CGonly ccarith "dec"

       .IL LEA irlnk stc
       32-bit load effective address instruction.  This only appears in the
       linear and attributed ILIs, not the shared ILIs.  The LILI is created
       by 'cglinear.c:optimize_imul()', in which case 'irlnk' is used as both
       the base and index register, and 'stc' is the shift count, which may
       be 1, 2, 4 or 8.  The AILI may be generated from a LEA LILI or it may
       be created by a peephole optimisation.
       .AT arth null ir cse
       .CG CGonly "lea" 'l'

       .IL KLEA krlnk stc
       Used by the 64-bit compiler only.
       .AT arth null kr cse
       .CG notCG

       .IL MOV
       Synonym for LD and ST, and register to register moves.
       .AT move null ir cse
       .CG CGonly "mov" move

       .IL MOVABS
       Not used by X86_32 compiler
       .AT move null ir cse
       .CG notCG notAILI

       .IL BIH stc stc
       Created by the code generator to represent, in the linear ili and the AILI,
       the beginning of a basic block.  The first operand is the bih number, and
       the second is the label symbol table pointer, if any.
       .AT other null trm dom
       .CG CGonly terminal asm_nop

       .IL DEF
       Placed into the AILI to indicate the definition of a register which is
       otherwise not explicitly defined (by appearing in the 'dest' field of
       some aili).  The register allocators need this information in certain
       cases.
       .AT other null trm
       .CG CGonly asm_nop

       .IL USE
       Placed into the AILI to indicate the use of a register which is otherwise
       not explicitly used.  The register allocators need to know this in order
       to avoid a conflicting register allocation, etc.
       .AT other null trm
       .CG CGonly asm_nop

       .IL STACK_ADJ
       Placed into the AILI to indicate that the stack pointer has been
       modified by the value specified in the src1 field of the aili.
       No code is generated for this ili.
       .AT other null trm
       .CG CGonly asm_special

       .IL ALLOC krlnk
       Allocate memory for a C or C++ variable length array.
       'krlnk' is the size.  Result is the address of the allocated memory.
       .AT arth null ar
       .CG notCG

       .IL DEALLOC arlnk
       Deallocate memory that was allocated by ALLOC.
       'arlnk' is the memory address.
       .AT other null trm
       .CG notCG

       .IL ALLOCA krlnk
       Allocate memory with alloca
       'krlnk' is the size.  Result is the address of the allocated memory.
       .AT arth null ar
       .CG notCG

       .IL CFA arlnk nme
       Materialize the outer call frame address as a builtin.  This is
       placed into a load address register from a memory location whose address
       is represented by op1.
       .AT other null ar cse
       .CG 'l' asm_special

       .IL EHRET arlnk nme
       Materialize the return address of the caller as a builtin.  This is
       placed into a load address register from a memory location whose address
       is represented by op1.
       .AT other null ar cse
       .CG 'l' asm_special

       .IL EHREGS
       Materialize the return address of the caller as a builtin.  This is
       placed into a load address register from a memory location whose address
       is represented by op1.
       .AT other null trm
       .CG terminal asm_special

       .IL EHREGST sym sym
       Store implicit registers into the syms: catch_clause and caught_object
       .AT other null trm
       .CG asm_special terminal

       .IL EHREGLD sym sym
       Materialize the syms: catch_clause and caught_object into the two symbols
       from implicit registers
       .AT other null trm
       .CG asm_special terminal

       .IL EHRESUME sym sym
       Resume propagation of an existing in-flight exception whose unwinding was
       interrupted to run some cleanup code.
       .AT other null trm
       .CG asm_special terminal

       .IL ACCEL lnk
       Start a block of code to be targeted for accelerator
       .AT other null trm
       .CG notCG

       .IL ENDACCEL lnk
       End a block of code to be targeted for accelerator
       .AT other null trm
       .CG notCG

       .IL ACCKERNELS lnk
       Start a block of kernels to be targeted for accelerator
       .AT other null trm
       .CG notCG

       .IL ACCENDKERNELS lnk
       End a block of kernels to be targeted for accelerator
       .AT other null trm
       .CG notCG

       .IL ACCPAR lnk
       Start a block of parallel code to be targeted for accelerator
       .AT other null trm
       .CG notCG

       .IL ACCENDPAR lnk
       End a block of parallel code to be targeted for accelerator
       .AT other null trm
       .CG notCG

       .IL ACCSCALARREG lnk
       Start a block of code to run as a scalar kernel on the accelerator
       .AT other null trm
       .CG notCG

       .IL ACCENDSCALARREG
       End a block of code to run as a scalar kernel on the accelerator
       .AT other null trm
       .CG notCG

       .IL ACCSERIAL lnk
       Start a block of code to run as a serial kernel on the accelerator
       .AT other null trm
       .CG notCG

       .IL ACCENDSERIAL
       End a block of code to run as a serial kernel on the accelerator
       .AT other null trm
       .CG notCG

       .IL ACCELLP lnk
       The following loop is to be targeted for the accelerator
       .AT other null trm
       .CG notCG

       .IL ACCSLOOP lnk stc
       The following loop in a serial region is to be targeted for the accelerator
       The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;
       .AT other null trm
       .CG notCG

       .IL ACCKLOOP lnk stc
       The following loop in a kernels region is to be targeted for the accelerator
       The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;
       .AT other null trm
       .CG notCG

       .IL ACCPLOOP lnk stc
       The following loop in a parallel region is to be targeted for the accelerator
       The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;
       .AT other null trm
       .CG notCG

       .IL ACCATTACH lnk lnk lnk sym
       Attach the pointer/allocatable member in an aggregate structure data variable
       .AT other null lnk
       .CG notCG

       .IL ACCDETACH lnk lnk lnk sym
       Detach the pointer/allocatable member in an aggregate structure data variable
       .AT other null lnk
       .CG notCG

       .IL ACCCOPY lnk lnk lnk sym stc
       Variable or array will be copied from host to device and back
       .AT other null lnk
       .CG notCG

       .IL ACCCOPYIN lnk lnk lnk sym stc
       Variable or array will be copied from host to device
       .AT other null lnk
       .CG notCG

       .IL ACCCOPYOUT lnk lnk lnk sym stc
       Variable or array will be copied from device to host
       .AT other null lnk
       .CG notCG

       .IL ACCLOCAL lnk lnk lnk sym stc
       Variable or array will be allocated on the device but not copied
       to or from the host
       .AT other null lnk
       .CG notCG

       .IL ACCCREATE lnk lnk lnk sym stc
       Variable or array will be allocated on the device but not copied
       to or from the host
       .AT other null lnk
       .CG notCG


       .IL ACCDELETE lnk lnk lnk sym stc
       Variable or array will be deleted from the device but not copied
       to or from the host
       .AT other null lnk
       .CG notCG

       .IL ACCPDELETE lnk lnk lnk sym stc
       Variable or array will be deleted from the device but not copied, unless in a data region
       to or from the host
       .AT other null lnk
       .CG notCG

       .IL ACCPRESENT lnk lnk lnk sym stc
       Variable or array must be present on the device
       .AT other null lnk
       .CG notCG

       .IL ACCPCOPY lnk lnk lnk sym stc
       Variable or array may be present on the device, but if not will be copied
       .AT other null lnk
       .CG notCG

       .IL ACCPCOPYIN lnk lnk lnk sym stc
       Variable or array may be present on the device, but if not will be copied in
       .AT other null lnk
       .CG notCG

       .IL ACCPCOPYOUT lnk lnk lnk sym stc
       Variable or array may be present on the device, but if not will be copied out
       .AT other null lnk
       .CG notCG

       .IL ACCPCREATE lnk lnk lnk sym stc
       Variable or array may be present on the device, but if not will be allocated,
       but not copied
       .AT other null lnk
       .CG notCG

       .IL ACCPNOT lnk lnk lnk sym stc
       Variable or array may be present on the device, but if not will NOT be allocated
       nor copied.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth argument is the symbol that points to the device copy, if there is such
       a symbol.
       Fifth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCNO_CREATE lnk lnk lnk sym stc
       Variable or array may be present on the device, but if not will NOT be allocated
       nor copied.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth argument is the symbol that points to the device copy, if there is such
       a symbol.
       Fifth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCUPDATEHOST lnk lnk lnk stc
       Variable or array will be copied from device back to host.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCUPDATESELF lnk lnk lnk stc
       Variable or array will be copied from device back to the current thread.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCUPDATEDEV lnk lnk lnk stc
       Variable or array will be copied from host to device.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCUPDATEHOSTIFP lnk lnk lnk stc
       Variable or array will be copied from device back to host, if present.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCUPDATESELFIFP lnk lnk lnk stc
       Variable or array will be copied from device back to the current thread, if present.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCUPDATEDEVIFP lnk lnk lnk stc
       Variable or array will be copied from host to device, if present.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCUPDATE lnk
       Head of a list of update clauses
       .AT other null trm
       .CG notCG

       .IL PCASTCOMPARE lnk
       Head of a list of PCAST compare clauses.
       .AT other null trm
       .CG notCG

       .IL ACCCOMPARE lnk lnk lnk stc
       Variable or array will be copied from device back to host.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL PGICOMPARE lnk lnk lnk stc
       Variable or array will be copied from device back to host.
       First link is to next clause.
       Second link is to the array bounds.
       Third link is to ACCSYMLNK.
       Fourth arg is the policy index
       .AT other null lnk
       .CG notCG

       .IL ACCPRIVATE lnk lnk lnk
       Variable or array is private to an iteration of the loop or to a worker
       .AT other null lnk
       .CG notCG

       .IL ACCFIRSTPRIV lnk lnk lnk
       Variable or array is private to the workers, but initialize with values from the host
       .AT other null lnk
       .CG notCG

       .IL ACCCACHE lnk lnk lnk
       The compiler should move the array to the highest level of the
       software-managed cache
       .AT other null lnk
       .CG notCG

       .IL ACCDEVICEPTR lnk lnk lnk sym stc
       Variable or array will be copied from device to host
       .AT other null lnk
       .CG notCG

       .IL ACCAUTO lnk stc
       The execution mode will be selected by the compiler (gang/worker/vector/seq)
       First link is to next clause.
       Last argument is the device_type argument.
       .AT other null lnk
       .CG notCG


       .IL ACCVECTOR lnk lnk stc
       The iterations of the loop will be executed in vector mode on the accelerator
       .AT other null lnk
       .CG notCG

       .IL ACCPARALLEL lnk lnk stc
       The iterations of the loop will be executed in parallel on the accelerator
       .AT other null lnk
       .CG notCG

       .IL ACCGANG lnk lnk stc stc
       The iterations of the loop will be executed in across gangs on the accelerator.
       First argument is the link to the next clause.
       Second argument is the number of gangs.
       Third argument is the device_type argument.
       Fourth argument is the dimension, where the default is dimension zero (cuda X dimension).
       .AT other null lnk
       .CG notCG

       .IL ACCGANGCHUNK lnk lnk stc
       The gang static-scheduling chunk size.
       First argument is the link to the next clause.
       Second argument is the chunk size.
       Last argument is the device_type argument.
       .AT other null lnk
       .CG notCG

       .IL ACCWORKER lnk lnk stc
       The iterations of the loop will be executed in across workers on the accelerator
       .AT other null lnk
       .CG notCG

       .IL ACCSEQ lnk lnk stc
       The iterations of the loop will be executed sequentially on the accelerator
       .AT other null lnk
       .CG notCG

       .IL ACCHOST lnk lnk stc
       The iterations of the loop will be executed on the host
       .AT other null lnk
       .CG notCG

       .IL ACCSHORTLOOP lnk stc
       Trip count is less than the maximum size of a vector operation
       (for vector schedule) or less than the maximum number of
       simultaneously active parallel iterations (for parallel schedule)
       .AT other null lnk
       .CG notCG


       .IL ACCTILE lnk lnk stc stc
       Tile this loop.
       First link is to the next clause.
       Second link is to a list of ACCSIZE ILI.
       Third argument is the tile depth.
       Last argument is the device_type argument.
       .AT other null lnk
       .CG notCG

       .IL ACCSIZE lnk lnk
       A size expression.
       The first link is to the next size expression, if any, or to NULL.
       The second link is the expression, if any, or to NULL.
       .AT other null lnk
       .CG notCG

       .IL ACCINDEPENDENT lnk
       The iterations of the loop are data-independent
       .AT other null lnk
       .CG notCG

       .IL ACCNUMGANGS lnk lnk stc stc
       How many gangs to instantiate
       First link is the link to the next clause.
       Second argument is the number of gangs.
       Third argument is the device_type argument.
       Fourth argument is the dimension, where the default is dimension zero (cuda X dimension).
       .AT other null lnk
       .CG notCG

       .IL ACCNUMWORKERS lnk lnk stc
       How many workers to instantiate
       .AT other null lnk
       .CG notCG

       .IL ACCVLENGTH lnk lnk stc
       How long a vector to instantiate
       .AT other null lnk
       .CG notCG

       .IL ACCIF lnk lnk
       Region will execute conditionally on host or accelerator.
       .AT other null lnk
       .CG notCG

       .IL ACCDEVID lnk lnk stc
       Device ID of the device to use for this directive or construct.
       .AT other null lnk
       .CG notCG

       .IL ACCUNROLL lnk lnk stc stc
       Control loop unrolling; the 3rd element tells whether it's the parallel, vector, or sequential loop to be unrolled
       .AT other null lnk
       .CG notCG

       .IL ACCKERNEL lnk
       .AT other null lnk
       .CG notCG

       .IL ACCTRIPLE lnk lnk lnk lnk
       Specify bounds of sub-arrays in accelerator clauses.
       .AT other null lnk
       .CG notCG

       .IL ACCDATAREG lnk
       Generate data movement to/from accelerator
       .AT other null trm
       .CG notCG

       .IL ACCENTERDATA lnk
       Generate data movement at enter data directive
       .AT other null trm
       .CG notCG

       .IL ACCEXITDATA lnk
       Generate data movement at exit data directive
       .AT other null trm
       .CG notCG

       .IL ACCFINALEXITDATA lnk
       Generate data movement at exit data directive with finalize clause.
       Link to list of arguments.
       .AT other null trm
       .CG notCG

       .IL ACCENDDATAREG
       Generate matching data movement to/from accelerator
       .AT other null trm
       .CG notCG

       .IL ACCPHI lnk stc stc
       PHI operator used in accelerator optimizing code generator.
       Link points to ACCPHILINK, and the 2nd operand is a symbol numbering.
       3rd operand is nonzero for loop header phi
       .AT other null trm
       .CG notCG notAILI accel

       .IL ACCLHPHI lnk stc
       PHI operator for loop headers used in accelerator optimizing code generator.
       Link points to ACCPHILINK, and the 2nd operand is a symbol numbering.
       .AT other null trm
       .CG notCG notAILI accel

       .IL ACCPHILINK lnk lnk
       PHI operator for loop headers used in accelerator optimizing code generator.
       First link is to next PHILINK, 2nd link is the chain to the reaching def.
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCINIT
       Dummy initial value for factored use-def chains.
       First link is to next PHILINK, 2nd link is the chain to the reaching def.
       .AT other null trm
       .CG notCG notAILI accel


       .IL ACCVAR stc
       Used in accelerator optimizing code generator, a builtin variable ref.
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCLDSYM stc stc
       Used in accelerator optimizing code generator, a load of a temp variable
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCSTSYM lnk stc stc
       Used in accelerator optimizing code generator, a load of a temp variable
       .AT other null trm
       .CG notCG notAILI accel

       .IL ACCIVAL stc stc
       Used in accelerator optimizing code generator, a literal constant;
       uses two operands to hold an ISZ_T value.
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCJSR stc lnk
       Used in accelerator optimizing code generator, special routine call
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCRETURN stc lnk
       Used in accelerator optimizing code generator, return value from a function call
       Short constant holds the return datatype.
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCLOR lnk lnk
       Used in accelerator optimizing code generator, logical OR
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCCAST lnk stc
       Used in accelerator optimizing code generator, type casting
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCJMP lnk sym
       Used in accelerator optimizing code generator, conditional jump
       The 'sym' is a normally an ACBLK index.  During linearization, the 'stc' will
       be a symbol index if positive and an ACBLK index negated if negative, until
       'acc_replace_labels'.
       .AT branch null lnk
       .CG notCG notAILI accel

       .IL ACCARG lnk lnk
       Used in accelerator optimizing code generator, argument list
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCBOUND lnk lnk stc stc
       Used in accelerator optimizing code generator, array bounds check.
       Fields are subscript expression, ACCBOUND2, line number, array symbol
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCBOUND2 lnk lnk stc
       Used in accelerator optimizing code generator, array bounds check.
       Fields are lower bound, upper bound, subscript number.
       .AT other null lnk
       .CG notCG notAILI accel

       .IL ACCWAIT lnk stc
       Used in accelerator code, wait on the host for each kernel to finish
       .AT other null lnk
       .CG notCG notAILI

       .IL ACCNOWAIT lnk
       Used in accelerator code, don't wait on the host for each kernel to finish
       .AT other null lnk
       .CG notCG notAILI

       .IL ACCASYNC lnk lnk stc
       Used in accelerator code, perform this activity asynchronously
       .AT other null lnk
       .CG notCG notAILI

       .IL ACCWAITDIR lnk
       Used in accelerator code, wait on the host for async activities to finish
       .AT other null trm
       .CG notCG notAILI

       .IL ACCWAITARG lnk lnk stc
       Used in accelerator code, wait on the host for async activities to finish
       .AT other null lnk
       .CG notCG notAILI

       .IL ACCLOOP lnk stc sym
       Used in accelerator code, to generate an explicit 'vector' loop.
       The first argument is the trip count, the second is an accelerator symbol number of the loop variable.
       The third argument is the label of the exit branch.
       .AT branch null trm
       .CG notCG notAILI accel

       .IL ACCENDLOOP sym
       Used in accelerator code, to end an explicit 'vector' loop.
       The argument is the label of the top of the loop.
       .AT branch null trm
       .CG notCG notAILI accel

       .IL KERNEL lnk
       Start a nest of loops to be turned into CUDA kernels
       .AT other null trm
       .CG notCG

       .IL ENDKERNEL lnk
       End a nest of loops to be turned into CUDA kernels
       .AT other null trm
       .CG notCG

       .IL KERNELBLOCK lnk lnk stc
       Block size for one kernel loop.
       The constant is the loop nest level.
       .AT other null trm
       .CG notCG

       .IL KERNELGRID lnk lnk stc
       Grid size for one kernel loop.
       The constant is the loop nest level.
       .AT other null trm
       .CG notCG

       .IL KERNELNEST lnk stc
       nest depth of kernel loops
       .AT other null trm
       .CG notCG

       .IL KERNELSTREAM lnk stc
       stream argument to CUF kernel
       .AT other null trm
       .CG notCG

       .IL KERNELDEVICE lnk stc
       device argument to CUF kernel
       .AT other null trm
       .CG notCG


       .IL ACCIMPDATAREG lnk stc
       Generate data movement to/from accelerator.
       This is for the implicit data region; the constant is normally zero,
       but is '1' when there is a need for a pgi_cu_init call regardless of
       whether there is any data to move or allocate
       .AT other null trm
       .CG notCG

       .IL ACCENDIMPDATAREG stc
       Generate matching data movement to/from accelerator
       This is for the implicit data region
       The short constant tells how many implicit data regions were generated
       .AT other null trm
       .CG notCG

       .IL ACCMIRROR lnk lnk lnk sym
       Variable or array will be mirrored on the device as on the host
       .AT other null lnk
       .CG notCG

       .IL ACCREFLECT lnk lnk lnk sym
       Variable or array has been reflected on the device as on the host
       .AT other null lnk
       .CG notCG

       .IL ACCREDUCTION lnk lnk lnk stc
       Variable is a reduction variable.  'stc' is the operator.
       .AT other null lnk
       .CG notCG

       .IL ACCCACHEDIR lnk stc
       Accelerator CACHE directive.
       The 'stc' argument is normally zero, but is set to '1' if this is a 'readonly' cache directive.
       .AT other null lnk
       .CG notCG

       .IL ACCCACHEARG lnk lnk lnk
       Accelerator CACHE argument.
       .AT other null lnk
       .CG notCG

       .IL ACCHOSTDATA lnk
       Begin host data region.
       .AT other null trm
       .CG notCG

       .IL ACCENDHOSTDATA
       End host data region.
       .AT other null trm
       .CG notCG

       .IL ACCUSEDEVICE lnk lnk lnk sym
       Use the device address of a variable or array.
       .AT other null lnk
       .CG notCG

       .IL ACCUSEDEVICEIFP lnk lnk lnk sym
       Use the device address of a variable or array, if present
       .AT other null lnk
       .CG notCG

       .IL ACCSYMLNK sym lnk lnk nme
       This is used from a link from many other accelerator ILI to
       recover the original symbol as well as a link to the address tree,
       if appropriate.
       Symbol is a symbol pointer.
       The first link is a link to reference the symbol.
       The second link is a link to reference the parent of the symbol, if the symbol was a member.
       The constant value is the NME of the parent, if the symbol was a member.
       .AT other null lnk
       .CG notCG

       .IL ACCCOLLAPSE lnk stc stc stc
       Number of loops associated with the loop construct.
       First link to next argument.
       Second argument is the collapse depth.
       Third argument is set if this is a nontightly nested loop (force)
       Last argument is the device_type argument.
       .AT other null lnk
       .CG notCG

       .IL ACCDEFNONE lnk
       Tells the accelerator CG that a default-none clause is in effect.
       The link is to other clauses.
       .AT other null lnk
       .CG notCG

       .IL ACCDEFPRESENT lnk
       Tells the accelerator CG that a default-present clause is in effect.
       The link is to other clauses.
       .AT other null lnk
       .CG notCG

       .IL ACCDEVICERES lnk lnk lnk sym
       Variable or array will be resident on the device.
       .AT other null lnk
       .CG notCG

       .IL ACCLINK lnk lnk lnk sym
       A link to the variable or array will be resident on the device.
       .AT other null lnk
       .CG notCG

       .IL ACCLOOPPRIVATE sym
       The symbol must be made implicitly private in the containing loop.
       .AT other null trm
       .CG notCG

       .IL ACCJMPTABLE lnk lnk stc
       Used in the Accelerator CG.
       A jump table.
       The first link is to a linked list of ACCJMPENTRY ACLILI.
       The second link is to the expression used to index the table.
       The 'stc' is an ACBLK index of the default jump target.
       .AT other null trm
       .CG notCG

       .IL ACCJMPENTRY lnk lnk stc
       Used in the Accelerator CG.
       A jump table entry.
       The first link is to the next entry in a linked list of ACCJMPENTRY ACLILI.
       The second link is to an ACCIVAL that contains the value to match for this jump table entry.
       The 'stc' is an ACBLK index of this jump target.
       .AT other null lnk
       .CG notCG


       .IL ARGQP dplnk lnk
       Defines a quad precision memory argument used in m128 support
       \'dplnk' points to the register value of the argument.
       \'lnk' points to the next ARG ILI.
       .AT define null lnk
       .CG memarg "movupd"

       .IL ARG256 dplnk lnk
       Defines a 256-bit argument used in m256 support
       \'dplnk' points to the register value of the argument.
       \'lnk' points to the next ARG ILI.
       .AT define null lnk
       .CG memarg "movupd" sse_avx

       .IL GENARG lnk lnk stc stc
       Define an argument for a function call.
       The ARG ILIs for all of a function's arguments are linked together.
       \'lnk1' points to the argument.
       \'lnk2' points to the next ARG ILI.
       \'stc1' is the datatype of the argument, if available
       \'stc2' is the NME
       .AT define null lnk
       .CG notCG

       .IL GENARG2 lnk lnk stc stc
       Define 2nd argument of an argument pair for a function call.
       This will be linked immediately to the matching GENARG
       The ARG ILIs for all of a function's arguments are linked together.
       \'lnk1' points to the argument.
       \'lnk2' points to the next ARG ILI.
       \'stc1' is the datatype of the argument, if available
       \'stc2' is the NME
       .AT define null lnk
       .CG notCG

       .IL RETURN lnk stc nme
       Define return value from a function.
       \'lnk' points to the return value.
       \'stc' is the datatype of the argument.
       \'nme' is the nme of the argument
       .AT move null trm
       .CG notCG

       .IL VCON sym
       .AT cons null lnk cse vect
       .CG notCG
       .IL VLD arlnk nme stc
       For all vector ILI except VCON the last operand is the vector dtype
       .AT load null lnk vect
       .CG notCG
       .IL VLDU arlnk nme stc
       .AT load null lnk vect
       .CG notCG
       .IL VNEG lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VADD lnk lnk stc
       .AT arth comm lnk cse vect
       .CG notCG
       .IL VSUB lnk lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VMUL lnk lnk stc
       .AT arth comm lnk cse vect
       .CG notCG
       .IL VDIV lnk lnk lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VDIVZ lnk lnk lnk stc
       Vector divide where divide by zero does not fault.
       .AT arth null lnk cse vect
       .CG notCG
       .IL VMOD lnk lnk lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VMODZ lnk lnk lnk stc
       Vector remainder where divide by zero does not fault.
       .AT arth null lnk cse vect
       .CG notCG
       .IL VCVTV lnk stc stc
       .AT arth null lnk cse vect
       .IL VCVTS lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VCVTR lnk stc stc
       Reinterpret the bits of a vector as if they were a different vector type.
       This should always be a no-op at runtime.
       .AT arth null lnk cse vect
       .IL VNOT lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VAND lnk lnk stc
       .AT arth comm lnk cse vect
       .CG notCG
       .IL VOR lnk lnk stc
       .AT arth comm lnk cse vect
       .CG notCG
       .IL VXOR lnk lnk stc
       .AT arth comm lnk cse vect
       .CG notCG
       .IL VCMPNEQ lnk lnk stc
       Used for single-precision square root approximation.
       .AT arth comm lnk cse vect
       .CG notCG
       .IL VLSHIFTV lnk lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VRSHIFTV lnk lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VLSHIFTS lnk lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VRSHIFTS lnk lnk stc
       .AT arth null lnk cse vect
       .CG notCG
       .IL VURSHIFTS lnk lnk stc
       Vector unsigned (logical) right shift by a scalar
       .AT arth null lnk cse vect
       .CG notCG
       .IL VMIN lnk lnk stc
       Vector minimum
       .AT arth null lnk cse vect
       .CG notCG
       .IL VMAX lnk lnk stc
       Vector maximum
       .AT arth null lnk cse vect
       .CG notCG
       .IL VABS lnk stc
       Vector absolute value
       .AT arth null lnk cse vect
       .CG notCG
       .IL VSQRT lnk lnk stc
       Vector square root
       .AT arth null lnk cse vect
       .CG notCG
       .IL VCOS lnk lnk stc
       Vector cosine - final link is potential mask as it is
       for all the math intrinsic calls (will be IL_NULL if no mask)
       .AT arth null lnk cse vect
       .CG notCG
       .IL VSIN lnk lnk stc
       Vector sine
       .AT arth null lnk cse vect
       .CG notCG
       .IL VSINCOS lnk lnk stc
       Vector sine-cosine
       .AT arth null lnk cse vect
       .CG notCG
       .IL VASIN lnk lnk stc
       Vector arc sine
       .AT arth null lnk cse vect
       .CG notCG
       .IL VACOS lnk lnk stc
       Vector arc cosine
       .AT arth null lnk cse vect
       .CG notCG
       .IL VATAN lnk lnk stc
       Vector arctangent
       .AT arth null lnk cse vect
       .CG notCG
       .IL VATAN2 lnk lnk lnk stc
       Vector arctangent2
       .AT arth null lnk cse vect
       .CG notCG
       .IL VTAN lnk lnk stc
       Vector tangent
       .AT arth null lnk cse vect
       .CG notCG
       .IL VSINH lnk lnk stc
       Vector hyperbolic sine
       .AT arth null lnk cse vect
       .CG notCG
       .IL VCOSH lnk lnk stc
       Vector hyperbolic cosine
       .AT arth null lnk cse vect
       .CG notCG
       .IL VTANH lnk lnk stc
       Vector hyperbolic tangent
       .AT arth null lnk cse vect
       .CG notCG
       .IL VEXP lnk lnk stc
       Vector natural exponential
       .AT arth null lnk cse vect
       .CG notCG
       .IL VLOG lnk lnk stc
       Vector natural logarithm
       .AT arth null lnk cse vect
       .CG notCG
       .IL VLOG10 lnk lnk stc
       Vector logarithm base 10
       .AT arth null lnk cse vect
       .CG notCG
       .IL VPOW lnk lnk lnk stc
       Vector pow float
       .AT arth null lnk cse vect
       .CG notCG
       .IL VPOWI lnk lnk lnk stc
       Vector pow float to integer
       .AT arth null lnk cse vect
       .CG notCG
       .IL VPOWK lnk lnk lnk stc
       Vector pow float to integer\*8
       .AT arth null lnk cse vect
       .CG notCG
       .IL VPOWIS lnk lnk lnk stc
       Vector pow float to scalar integer
       .AT arth null lnk cse vect
       .CG notCG
       .IL VPOWKS lnk lnk lnk stc
       Vector pow float to scalar integer\*8
       .AT arth null lnk cse vect
       .CG notCG
       .IL VFPOWK lnk lnk lnk stc
       Vector pow float to integer\*8
       .AT arth null lnk cse vect
       .CG notCG
       .IL VFPOWKS lnk lnk lnk stc
       Vector pow float to scalar integer\*8
       .AT arth null lnk cse vect
       .CG notCG
       .IL VDPOWI lnk lnk lnk stc
       Vector pow double to integer
       .AT arth null lnk cse vect
       .CG notCG
       .IL VDPOWIS lnk lnk lnk stc
       Vector pow double to scalar integer
       .AT arth null lnk cse vect
       .CG notCG
       .IL VRSQRT lnk lnk stc
       Vector reciprocal square root
       .AT arth null lnk cse vect
       .CG notCG
       .IL VFLOOR lnk lnk stc
       Vector floor
       .AT arth null lnk cse vect
       .CG notCG
       .IL VCEIL lnk lnk stc
       Vector ceiling
       .AT arth null lnk cse vect
       .CG notCG
       .IL VAINT lnk lnk stc
       Vector truncation
       .AT arth null lnk cse vect
       .CG notCG
       .IL VRCP lnk lnk stc
       Vector reciprocal
       .AT arth null lnk cse vect
       .CG notCG
       .IL VST lnk arlnk nme stc
       .AT store null trm vect
       .CG terminal notCG
       .IL VSTU lnk arlnk nme stc
       .AT store null trm vect
       .CG terminal notCG
       .IL VFMA1 lnk lnk lnk stc
       Vector FMA for LLVM intrinsic - lnk1\*lnk2+lnk3, with stc the dtype
       .AT arth null lnk cse vect
       .CG notCG
       .IL VFMA2 lnk lnk lnk stc
       Vector FMA for LLVM intrinsic - lnk1\*lnk2-lnk3, with stc the dtype
       .AT arth null lnk cse vect
       .CG notCG
       .IL VFMA3 lnk lnk lnk stc
       Vector FMA for LLVM intrinsic - -lnk1\*lnk2+lnk3, with stc the dtype
       .AT arth null lnk cse vect
       .CG notCG
       .IL VFMA4 lnk lnk lnk stc
       Vector FMA for LLVM intrinsic - -lnk1\*lnk2-lnk3, with stc the dtype
       .AT arth null lnk cse vect
       .CG notCG
       .IL VPERMUTE lnk lnk lnk stc
       Shuffle contents of vector registers. lnk1 and lnk2 can be the same vector
       or lnk2 can be null. lnk1 dtype is used as dtype for both lnk1 and lnk2,
       unless lnk2 is null. stc is the result dtype, lnk3 is a vector constant
       representing a mask where each field represents which L-to-R element of
       concatenated <lnk1,lnk2> vector is to be placed in corresponding result
       field. lnk3 size must match the size of the result vector, but can be
       different than lnk1 and lnk2's size.
       .AT other null lnk vect
       .CG notCG
       .IL VBLEND lnk lnk lnk stc
       Vector blend/select of lnk2 & lnk3. lnk1 is the mask, stc is the dtype
       .AT other null lnk cse vect
       .CG notCG
       .IL VCMP stc lnk lnk stc
       Vector compare of lnk1 & lnk2. stc1 is the condition code, stc2 is the dtype
       .AT arth null lnk cse vect
       .CG notCG

       .IL BCONCUR sym lnk
       Start auto parallel region of an outlined function sym.
       .AT other null trm
       .CG notCG

       .IL ECONCUR sym
       End auto parallel region  of an outliend function sym.
       .AT other null trm
       .CG notCG

       .IL HFADD hplnk hplnk
       Half-precision floating-point addition.
       .AT arth comm hp cse
       .CG notCG

       .IL HFNEG hplnk
       Half-precision negation.
       .AT arth null hp cse
       .CG notCG

       .IL HFSUB hplnk hplnk
       Half-precision floating-point subtraction.
       .AT arth null hp cse
       .CG notCG

       .IL HFMUL hplnk hplnk
       Half-precision floating-point multiply.
       .AT arth comm hp cse
       .CG notCG

       .IL HFDIV hplnk hplnk
       Half-precision divide.
       .AT arth null hp cse
       .CG notCG

       .IL HFCMP hplnk hplnk stc
       Half float compare with result of true or false.
       .AT arth null ir cse
       .CG notCG

       .IL HFCMPZ hplnk stc
       Half float compare with zero; result is TRUE or FALSE.
       .AT arth null ir cse
       .CG notCG

       .IL DFRHP lnk hp
       Define half precision function result.
       .AT define null hp cse
       .CG terminal asm_nop

       .IL HFCON sym
       Half-precision floating-point constant.
       .AT cons null hp cse
       .CG notCG

       .IL LDHP arlnk nme stc
       Load half-precision floating value.  'stc' is not used.
       .AT load null hp
       .CG notCG

       .IL HP2SP hplnk
       Half precison to single precision conversion.
       .AT arth null sp
       .CG notCG

       .IL SP2HP splnk
       Single precison to half precision conversion.
       .AT arth null hp
       .CG notCG

       .IL DP2HP dplnk
       Double precison to half precision conversion.
       .AT arth null hp
       .CG notCG

       .IL STHP hplnk arlnk nme stc
       Store half precision quantity.  'stc' must be MSZ_F2.
       .AT store null trm
       .CG notCG

       .IL ARGHP hplnk lnk
       Defines a half-precision memory argument.
       \'hplnk' points to the register value of the argument.
       \'lnk' points to the next ARG ILI.
       .AT define null lnk
       .CG notCG

       .IL CSEHP hplnk
       Half precision register cse.
       .AT arth null hp
       .CG notCG

       .IL HFCJMP hplnk hplnk stc sym
       Half precision compare and jump to the label 'sym'
       if the condition, denoted by stc, is true.
       .AT branch null trm dom
       .CG terminal conditional_branch notAILI

       .IL HFCJMPZ hplnk stc sym
       Half precision compare with zero and branch to label 'sym'.
       .AT branch null trm dom
       .CG notCG conditional_branch

       .IL MVHP hplnk ir
       Move half FP value into specific integer register, ir.
       .AT move null trm
       .CG terminal notAILI 'l'

       .IL HFMAX hplnk hplnk
       Half-precision max
       .AT arth comm hp cse
       .CG notCG

       .IL HFMIN hplnk hplnk
       Half-precision min
       .AT arth comm hp cse
       .CG notCG

       .so ilitp_atomic.n

       .so ilitp_longdouble.n
